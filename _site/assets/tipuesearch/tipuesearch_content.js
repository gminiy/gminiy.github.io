var tipuesearch = {"pages": [{
    "title": "[NestJs] 동적 모듈을 활용한 환경 변수 구성",
    "text": "1. 동적 모듈 2. dotenv를 이용한 Config 설정 3. Nest에서 제공하는 Config 패키지 4. 유저 서비스에 환경 변수 구성하기 4.1 커스텀 Config 파일 작성 4.2 동적 ConfigModule 등록 1. 동적 모듈 동적 모듈 (Dynamic Module) 은 모듈이 생성될 때 동적으로 변수들이 정해진다. 실행 환경에 따라 환경 변수를 관리하는 모듈인 Config 모듈이 대표적인 예다. 2. dotenv를 이용한 Config 설정 NodeJs의 dotenv 라이브러리를 통해 환경 변수를 설정한다. dotenv는 .env확장자를 가진 파일을 읽어서 환경 변수를 설정한다. dotenv를 설치하자. $ npm i dotenv $ npm i -D @types/dotenv dotenv는 루트 디렉터리에 있는 .env확장자 파일을 읽는다. DTABASE_HOST라는 환경 변수를 각 파일에 저자한다. .development.env DATABASE_HOST = local; .stage.env DATABASE_HOST = stage - reader.dextto.com; .production.env DATABASE_HOST = prod - reader.dextto.com; package.json 을 수정해서 NODE_ENV를 설정되도록 한다. package.json \"prebuild\": \"rimraf dist\", \"start:dev\": \"npm run prebuild &amp;&amp; NODE_ENV=local nest start --watch\", env 파일을 읽어서 사용하도록 변경한다. main.ts import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import * as dotenv from \"dotenv\"; import * as path from \"path\"; dotenv.config({ path: path.resolve( process.env.NODE_ENV === \"production\" ? \".production.env\" : process.env.NODE_ENV === \"stage\" ? \".stage.env\" : \".local.env\" ), }); async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000); } bootstrap(); 3. Nest에서 제공하는 Config 패키지 앞에서 dotenv 패키지를 직접 사용했는데 Nest는 dotenv를 내부적으로 활용하는 @nestjs/config 패키지를 제공한다. 이를 이용해서 ConfigModule을 동적으로 생성할 수 있다. $ npm i @nestjs/config 이 패키지에는 ConfigModule이 이미 존재한다. 이 모듈을 동적 모듈로 가지고 온다. app.module.ts import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { ConfigModule } from \"@nestjs/config\"; @Module({ imports: [ConfigModule.forRoot()], controllers: [AppController], providers: [AppService], }) export class AppModule {} forRoot는 DynamicModule을 리턴하는 정적 메서드로 ConfigModuleOptions를 인수로 받는다. forRoot() static forRoot(options?: ConfigModuleOptions): DynamicModule; ConfigModule은 소비 모듈이 원하는 옵션값을 전달하여 원하는 대로 동적으로 ConfigModule을 생성한다. ConfigModule export interface ConfigModuleOptions { /** * If \"true\", values from the process.env object will be cached in the memory. * This improves the overall application performance. * See: https://github.com/nodejs/node/issues/3104 */ cache?: boolean; /** * If \"true\", registers `ConfigModule` as a global module. * See: https://docs.nestjs.com/modules#global-modules */ isGlobal?: boolean; /** * If \"true\", environment files (`.env`) will be ignored. */ ignoreEnvFile?: boolean; /** * If \"true\", predefined environment variables will not be validated. */ ignoreEnvVars?: boolean; /** * Path to the environment file(s) to be loaded. */ envFilePath?: string | string[]; /** * Environment file encoding. */ encoding?: string; /** * Custom function to validate environment variables. It takes an object containing environment * variables as input and outputs validated environment variables. * If exception is thrown in the function it would prevent the application from bootstrapping. * Also, environment variables can be edited through this function, changes * will be reflected in the process.env object. */ validate?: (config: Record&lt;string, any&gt;) =&gt; Record&lt;string, any&gt;; /** * Environment variables validation schema (Joi). */ validationSchema?: any; /** * Schema validation options. * See: https://joi.dev/api/?v=17.3.0#anyvalidatevalue-options */ validationOptions?: Record&lt;string, any&gt;; /** * Array of custom configuration files to be loaded. * See: https://docs.nestjs.com/techniques/configuration */ load?: Array&lt;ConfigFactory&gt;; /** * A boolean value indicating the use of expanded variables, or object * containing options to pass to dotenv-expand. * If .env contains expanded variables, they'll only be parsed if * this property is set to true. */ expandVariables?: boolean | DotenvExpandOptions; } 루트 디렉터리에 있는 .env 파일을 환경 변수로 등록한다. app.module.ts import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { ConfigModule } from \"@nestjs/config\"; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: process.env.NODE_ENV === \"production\" ? \".production.env\" : process.env.NODE_ENV === \"stage\" ? \".stage.env\" : \".local.env\", }), ], controllers: [AppController], providers: [AppService, ConfigService], }) export class AppModule {} ConfigModule은 환경 변수 값을 가져오는 프로바이더인 ConfigService가 있다. 이를 원하는 컴포넌트에서 주입해서 사용하면 된다. import { Controller, Get } from '@nestjs/common'; import { ConfigService } from '@nestjs/config'; @Controller() export class AppController { constructor( private readonly configService: ConfigService, ) {} @Get('config') getConfig(): string { return this.configService.get('DATABASE_HOST'); } } 4. 유저 서비스에 환경 변수 구성하기 @nest/config 와 환경 변수 유효성 검사를 위한 joi를 설치한다. $ npm i @nestjs/config $ npm i joi .development.env EMAIL_SERVICE=Gmail EMAIL_AUTH_USER=YOUR-GAMIL EMAIL_AUTH_PASSWORD=YOUR-GMAIL-PASSWORD EMAIL_BASE_URL=http://localhost:3000 4.1 커스텀 Config 파일 작성 모든 환경 변수가 .env 파일에 선언되어 있지만, 가져다 쓸 대는 DatabaseConfig, EmailConfig와 같이 의미 있는 단위로 묶고 싶다면 ConfigModule을 이용해 구현할수 있다. src/config에 이메일 관련 환경 변수를 관리하는 emailConfig.ts를 작성한다. email 토큰으로 ConfigFactory를 등록하는 코드이다. emailConfig.ts import { registerAs } from \"@nestjs/config\"; export default registerAs(\"email\", () =&gt; ({ service: process.env.EMAIL_SERVICE, auth: { user: process.env.EMAIL_AUTH_USER, pass: process.env.EMAIL_AUTH_PASSWORD, }, baseUrl: process.env.EMAIL_BASE_URL, })); 4.2 동적 ConfigModule 등록 .env 파일을 루트 경로가 아니라 src/config/env 디렉터리에 모아서 관리한다. nest-cli.json { \"$schema\": \"https://json.schemastore.org/nest-cli\", \"collection\": \"@nestjs/schematics\", \"sourceRoot\": \"src\", \"compilerOptions\": { \"assets\": [ { \"include\": \"./config/env/*.env\", \"outDir\": \"./dist\" } ], \"watchAssets\": true // watch 모드에서 asset을 탐색하게 한다. } } AppModule에 ConfigModule을 등록한다. config는 전역모듈로 설정해서 모든 모듈에서 사용할 수 있게 한다. 유효성 검사를 위해 유효성 검사 객체를 작성한다. app.module.ts import { Module } from \"@nestjs/common\"; import { UsersModule } from \"./users/users.module\"; import { ConfigModule } from \"@nestjs/config\"; import emailConfig from \"./config/emailConfig\"; import { validateSchema } from \"./config/validateSchema\"; @Module({ imports: [ UsersModule, ConfigModule.forRoot({ envFilePath: [`${__dirname}/config/env/.${process.env.NODE_ENV}.env`], load: [emailConfig], isGlobal: true, validationSchema, }), ], controllers: [], providers: [], }) export class AppModule {} config/validateSchema.ts import * as Joi from \"joi\"; export const validateSchema = Joi.object({ EMAIL_SERVICE: Joi.string().required(), EMAIL_AUTH_USER: Joi.string().required(), EMAIL_AUTH_PASSWORD: Joi.string().required(), EMAIL_BASE_URL: Joi.string().required(), }); email.service.ts import Mail from 'nodemailer/lib/mailer'; import * as nodemailer from 'nodemailer'; import { Inject, Injectable } from '@nestjs/common'; import emailConfig from 'src/config/emailConfig'; import { ConfigType } from '@nestjs/config'; ... @Injectable() export class EmailService { private transporter: Mail; constructor( @Inject(emailConfig.KEY) private config: ConfigType&lt;typeof emailConfig&gt;, ) { this.transporter = nodemailer.createTransport({ service: config.service, auth: { user: config.auth.user, pass: config.auth.pass, }, }); } async sendMemberJoinVerification(email: string, signupVerifyToken: string) { const baseUrl = this.config.baseUrl; ... } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/28/nest-dynamic-module-env-config/"
  },{
    "title": "[NestJs] 모듈 설계",
    "text": "1. 모듈 1.1 모듈 다시 내보내기 1.2 전역 모듈 2. 유저 서비스 모듈 분리 2.1 UserModule 분리 2.2 EmailModule 분리 1. 모듈 모듈이란 여러 컴포넌트를 조합하여 더 큰 작업을 수행할 수 있게 하는 단위를 말한다. Nest 애플리케이션이 실행되기 위해서는 하나의 루트 모듈이 존재하고 이 루트 모듈은 다른 모듈들로 구성된다. 이를 통해 책임을 나누고 응집도를 높일 수 있다. 모듈을 어떻게 나눌 것인지는 명확한 기준은 없지만 유사한 기능끼리 모듈로 묶어서 설계하게 될 것이다. 모듈은 @Module 데커레이터를 사용한다. @Module 은 ModuleMetadata를 인수로 받으며 ModuleMetadata는 아래와 같이 정의된다. export declare function Module(metadata: ModuleMetadata): ClassDecorator; export interface ModuleMetadata { imports?: Array&lt;Type&lt;any&gt; | DynamicModule | Promise&lt;DynamicModule&gt; | ForwardReference&gt;; controllers?: Type&lt;any&gt;[]; providers?: Provider[]; exports?: Array&lt;DynamicModule | Promise&lt;DynamicModule&gt; | string | symbol | Provider | ForwardReference | Abstract&lt;any&gt; | Function&gt;; } import : 이 모듈에서 사용하기 위한 프로바이더를 가지고 있는 다른 모듈을 가지고 온다. controllers / providers : 컨트롤러와 프로바이더를 모듈에서 사용할수 있도록 Nest가 객체를 생성하고 주입할 수 있게 해준다. exports : 이 모듈에서 제공하는 컴포넌트를 다른 모듈에서 import 해서 사용하고자 한다면 export를 해야한다. export로 선언했다는 뜻은 어디서든 쓸 수 있으므로 public 인터페이스 또는 API로 간주된다. 1.1 모듈 다시 내보내기 가져온 모듈은 다시 내보내기가 가능하다. 예를 들어 AppModule이 CoreModule과 CommonModule의 기능이 모두 필요하다면 AppModule은 모두를 가지고 오는 것이 아니라 CoreModule만을 가져오고, CoreModule에서는 CommonModule을 내보내면 AppModule에서 CommonModule을 가지고 오지 않아도 사용할 수 있다. CommonModule.ts @Module({ providers: [CommonService], exports: [CommonService], // CommonService 제공 }) export class CommonModule {} CommonService.ts @Injectable() export class CommonService { hello(): string { return \"Common Hello~\"; } } CoreModule.ts @Module({ imports: [CommonModule], exports: [CommonModule], }) export class CoreModule {} AppModule.ts @Module({ imports: [CoreModule], controllers: [AppController], providers: [AppService], }) export class AppModule {} AppController.ts @Controller() export class AppController { constructor(private readonly commonService: CommonService) {} @Get('/common-hello') getCommonHello(): string { return this.commonService.hello(); } } 1.2 전역 모듈 Nest는 모듈 범위 내에서 프로바이더를 캡슐화한다. 따라서 어떤 모듈에 있는 프로바이더를 사용하려면 모듈을 먼저 import 해야한다. 하지만 헬퍼나 DB 연결 등의 전역적으로 쓸 수 있는 프로바이더가 필요한 경우 전역 모듈로 제공할 수 있다. 전역 모듈은 @Global 데커레이터를 선언한다. 전역 모듈은 루트 모듈이나 코어 모듈에서 한 번만 등록해야 한다. @Global() @Module({ providers: [CommonService], exports: [CommonService], }) export class CommonModule {} 2. 유저 서비스 모듈 분리 만들고 있는 유저 서비스는 루트 모듈인 AppModule만 존재한다. 유저 관리 기능을 UserModule로, 이메일 기능은 EmailModule로 분리하는 작업을 진행하자. 2.1 UserModule 분리 UserModule을 아래 cli 를 통해 생성한다. $ nest g mo Users 생성된 UserModule에 UserController와 UserService를 추가한다. EmailService를 사용하므로 함께 추가한다. user.module.ts import { Module } from \"@nestjs/common\"; import { UsersController } from \"./users.controller\"; import { UsersService } from \"./users.service\"; import { EmailService } from \"src/email/email.service\"; @Module({ imports: [], controllers: [UsersController], providers: [UsersService, EmailService], }) export class UsersModule {} AppModule에 UserModule이 자동으로 import 되어 있고 AppModule에서 UsersController, UsersService, EmailService를 참조할 필요가 없으므로 제거한다. app.module.ts import { Module } from \"@nestjs/common\"; import { UsersModule } from \"./users/users.module\"; @Module({ imports: [UsersModule], controllers: [], providers: [], }) export class AppModule {} 2.2 EmailModule 분리 이메일 모듈을 생성한다. $ nest g mo Email 생성된 EmailModule에서 EmailService를 UserModule에서 사용할수 있도록 exports 해준다. email.module.ts import { Module } from \"@nestjs/common\"; import { EmailService } from \"./email.service\"; @Module({ providers: [EmailService], exports: [EmailService], }) export class EmailModule {} UsersModule에서 EmailModule을 import해주고 EmailService는 삭제한다. users.module.ts import { Module } from \"@nestjs/common\"; import { UsersController } from \"./users.controller\"; import { UsersService } from \"./users.service\"; import { EmailModule } from \"src/email/email.module\"; @Module({ imports: [EmailModule], controllers: [UsersController], providers: [UsersService], }) export class UsersModule {} 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/27/nest-module/"
  },{
    "title": "[NestJs] 스코프",
    "text": "1. 스코프 1.1 프로바이더에 스코프 적용 1.2 컨트롤러에 스코프 적용 1. 스코프 Node.JS는 멀티 스레드 상태 비저장 모델을 따르지 않기 때문에 싱글턴 인스턴스를 사용하는 것이 권장된다. 하지만 요청별로 캐싱을 한다거나 요청 추적, 또는 멀티테넌시를 지원하기 위해서는 요청 기반으로 생명주기를 제한해야 한다. 아래는 스코프 종류이다. Default 싱글턴 인스턴스가 전체 애플리케이션에 공유됨 인스턴스 수명은 애플리케이션 생명주기와 같다. 애플리케이션이 부팅되면 모든 싱글턴 프로바이더의 인스턴스가 만들어진다. Request 들어오는 요청마다 별도의 인스턴스가 생성됨 요청을 처리하고 나면 인스턴스는 garbage-collected 됨 Transient 인스턴스는 공유되지 않는다. 이 프로바이더를 주입하는 각 컴포넌트는 새로 생성된 전용 인스턴스를 주입받는다. 1.1 프로바이더에 스코프 적용 @Injectable 데코레이터에 scope속성을 주는 방법 import { Injectable, Scope } from \"@nestjs/common\"; @Injectable({ scope: Scope.REQUEST }) export class CatsService {} 1.2 컨트롤러에 스코프 적용 @Controller 데코레이터는 ControllerOptions를 인수로 받을 수 있다. ContorllerOptions는 ScopeOptions를 상속한다. @Constroller({ path: \"cats\", scope: \"Scope.REQUEST\", }) export class CatsController {} 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/25/nest-scope/"
  },{
    "title": "[NestJs] 프로바이더",
    "text": "1. 프로바이더 1.1 프로바이더 등록 1.2 속성 기반 주입 2. 유저 서비스에 회원 가입 로직 구현 2.1 구현할 기능 목록 2.2 UserService 프로바이더 생성 2.3 회원 가입 2.4 회원 가입 이메일 발송 2.5 이메일 인증 2.6 로그인 2.7 유저 정보 조회 1. 프로바이더 앱이 제공하고자 하는 핵심 기능, 즉 비즈니스 로직을 수행하는 역하을 하는 것이 프로바이더이다. 컨트롤러가 이 역할을 수행하지 않고 분리함으로써 SRP에 부합하게 만든다. 프로바이더는 service, repository, factory, helper 등 여러 가지 형태로 구현이 가능하다. Nest에서 제공하는 프로바이더는 따로 라이브러리를 사용하지 않고 의존성을 주입할 수 있다. users.controller.ts @Controller('users') export class UsersController { constructor(private readonly usersService: UsersService) { } @Delete(':id') remove(@Param('id') id: string) { return this.usersService.remove(+id); } } 컨트롤러는 비즈니스 로직을 직접 수행하지 않는다. UsersController가 UsersService를 생성자를 통해 주입 받아서 멤버 변수에 할당해서 사용한다. 이때 UsersService에는 @Injectable 데코레이터를 선언해서 다른 어떤 Nest 컴포넌트에서도 주입할 수 있는 프로바이더가 된다. 별도의 스코프를 지정해주지 않으면 싱글턴 인스턴스가 된다. users.service.ts import { Injectable } from \"@nestjs/common\"; @Injectable() export class UsersService { remove(id: number) { return `This action removes a #${id} user`; } } 1.1 프로바이더 등록 module에서 등록을 해줘야 프로바이더로 사용할 수 있다. app.module.ts import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { UsersController } from \"./users/users.controller\"; @Module({ imports: [], controllers: [AppController, UsersController], providers: [AppService], }) export class AppModule {} 1.2 속성 기반 주입 프로바이더를 생성자를 통해 직접 주입받아 사용하지 않고 상속 관계에 있는 자식 클래스를 주입받아 사용하고 싶은 경우에 사용한다. export class BaseService { @Inject(ServiceA) private readonly serviceA: ServiceA; doSumeFuncFromA(): string { return this.serviceA.getHello(); } } BaseService 클래스의 ServieA 속성에 @Inject 데코레이터를 선언한다. 프로바이더에 정의된 클래스가 사용된다. 2. 유저 서비스에 회원 가입 로직 구현 2.1 구현할 기능 목록 회원 가입 이메일 인증 로그인 회원 정보 조회 2.2 UserService 프로바이더 생성 nest g s Users 명령어로 UsersService 프로바이더를 생성한다. app.module.ts에 UsersService가 자동으로 추가된다. 현재 src 디렉터리 내의 파일 구성은 아래와 같다. ├── app.controller.ts ├── app.module.ts ├── app.service.ts ├── main.ts └── users ├── UserInfo.ts ├── dto │ ├── create-user.dto.ts │ ├── user-login.dto.ts │ └── verify-email.dto.ts ├── users.controller.ts └── users.service.ts 2.3 회원 가입 회원 가입 요청을 구현한다. 먼저 POST /users 엔드포인트 담당 컨트롤러를 수정한다. uuid 라이브러리를 설치한다. $ npm i uuid users.controller.ts ... @Controller('users') export class UsersController { constructor(private userService: UsersService) {} // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { const { name, email, password } = dto; await this.userService.createUser(name, email, password); } ... UsersService를 생성자를 통해 주입받아 createUser에서 사용한다. UsersService 다음과 같이 구현한다. users.service.ts import { Injectable } from '@nestjs/common'; import * as uuid from 'uuid'; @Injectable() export class UsersService { async createUser( name: string, email: string, password: string, ): Promise&lt;void&gt; { await this.checkUserExists(email); const signupVerifyToken = uuid.v1(); await this.saveUser(name, email, password, signupVerifyToken); await this.sendMemberJoinEmail(email, signupVerifyToken); } private checkUserExists(email: string) { return false; // TODO: DB 연동 후 구현 } private saveUser( name: string, email: string, password: string, signupVerifyToken: string, ) { return; // TODO: DB 연동 후 구현 } private async sendMemberJoinEmail(email: string, signupVerifyToken: string) { return; // TODO: EmailService 프로바이더 구현 후 적용 } } 2.4 회원 가입 이메일 발송 여기서는 무료 이메일 전송 라이브러리인 nodemailer를 사용한다. $ npm i nodemailer $ npm i -D @types/nodemailer EmailService 프로바이더를 nest g s Email을 통해 생성한다. UserService에서 EmailService를 주입 받아서 sendMemverJoinEmail에서 emailService의 메소드를 호출한다. import { Injectable } from '@nestjs/common'; import { EmailService } from 'src/email/email.service'; import * as uuid from 'uuid'; @Injectable() export class UsersService { constructor(private emailService: EmailService) {} ... private async sendMemberJoinEmail(email: string, signupVerifyToken: string) { await this.emailService.sendMemberJoinVerification( email, signupVerifyToken, ); } } EmailService에서 sendMemberJoinVerification를 구현한다. import Mail from 'nodemailer/lib/mailer'; import * as nodemailer from 'nodemailer'; import { Injectable } from '@nestjs/common'; interface EmailOptions { to: string; subject: string; html: string; } @Injectable() export class EmailService { private transporter: Mail; constructor() { this.transporter = nodemailer.createTransport({ service: 'Gmail', auth: { user: 'YOUR_GMAIL', pass: 'YOUR_PASSWORD', }, }); } async sendMemberJoinVerification(email: string, signupVerifyToken: string) { const baseUrl = 'http://localhost:3000'; const url = `${baseUrl}/users/email-verify?signupVerifyToken=${signupVerifyToken}`; const mailOptions: EmailOptions = { to: email, subject: '가입 인증 메일', html: ` 가입확인 버튼을 누르시면 가입 인증이 완료됩니다.&lt;br/&gt; &lt;form action=\"${url}\" method=\"POST\"&gt; &lt;button&gt;가입확인&lt;/button&gt; &lt;/form&gt; `, }; return await this.transporter.sendMail(mailOptions); } } nodemailer는 구글 앱 비밀번호 로그인 를 참고하여 앱 비밀번호 설정해서 사용한다. 2.5 이메일 인증 받은 메일에서 가입확인 버튼을 눌렀을때 컨트롤러가 서비스 로직을 사용하도록 변경한다. users.controller.ts ... // 이메일 인증 @Post('/email-verify') async verifyEmail(@Query() dto: VerifyEmailDto): Promise&lt;void&gt; { const { signupVerifyToken } = dto; return await this.userService.verifyEmail(signupVerifyToken); } ... users.service.ts ... async verifyEmail(signupVerifyToken: string) { // TODO // 1. DB에서 signupVerifyToken으로 회원 가입 처리중인 유저가 있는지 조회하고 없다면 에러처리 // 2. 바로 로그인 상태가 되도록 JWT 발급 } ... 2.6 로그인 users.controller.ts ... // 로그인 @Post('login') async login(@Body() dto: UserLoginDto): Promise&lt;void&gt; { const { email, password } = dto; return await this.userService.login(email, password); } ... users.service.ts ... async login(email, password) { // TODO // 1. email, password를 가진 유저가 존재하는지 DB에서 확인하고 없다면 에러 처리 // 2. JWT 발급 } ... 2.7 유저 정보 조회 users.controller.ts ... // 회원 정보 조회 @Get(':id') async getUserInfo(@Param('id') userId: string): Promise&lt;UserInfo&gt; { return await this.userService.getUserInfo(userId); } ... users.service.ts ... async getUserInfo(userId: string): Promise&lt;UserInfo&gt; { // TODO // 1. UserId를 가진 유저가 존재하는지 DB에서 확인 후 없다면 에러 처리 // 2. 조회된 데이터를 UserInfo 타입으로 응답 throw new Error('Method not iplemented'); } ... 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/25/nest-provider/"
  },{
    "title": "[NestJs] 인터페이스",
    "text": "1. 컨트롤러 1.1 라우팅 1.2 요청 객체 1.3 응답 1.4 헤더 1.5 리디렉션 1.6 라우트 매개변수 1.7 하위 도메인 라우팅 1.9 페이로드 다루기 2. 유저 서비스의 인터페이스 1. 컨트롤러 Nest의 컨트롤러는 MVC 패턴에서 말하는 그 컨트롤러를 말한다. 컨트롤ㄹ러는 들어오는 요청을 받고 처리된 결과를 응답으로 돌려주는 인터페이스 역할을 한다. 컨트롤러를 작성해보자. 프로젝트 생성 $ nest new my-project cli를 통한 컨트롤러 생성 $ nest g controller Users AppModule 에서 생성한 users.controller.ts를 import 하는 부분이 추가된다. cli를 통해 보일러 플레이트를 한번에 만들 수 있다. module, controller, service, entity, dto, test 코드 등이 한번에 만들어진다. $ nest g resource Users ? What transport layer do you use? REST API ? Would you like to generate CRUD entry points? Yes CREATE src/users/users.controller.spec.ts (566 bytes) CREATE src/users/users.controller.ts (894 bytes) CREATE src/users/users.module.ts (248 bytes) CREATE src/users/users.service.spec.ts (453 bytes) CREATE src/users/users.service.ts (609 bytes) CREATE src/users/dto/create-user.dto.ts (30 bytes) CREATE src/users/dto/update-user.dto.ts (169 bytes) CREATE src/users/entities/user.entity.ts (21 bytes) UPDATE package.json (1990 bytes) UPDATE src/app.module.ts (389 bytes) ✔ Packages installed successfully. 1.1 라우팅 app.controller.ts import { Controller, Get } from '@nestjs/common'; import { AppService } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); } } @Controller 데코레이터를 통해 해당 클래스는 컨트롤러 역할을 하게 된다. getHello 함수는 @GET 데코레이터를 통해 라우팅된다. 라우팅 경로는 @Get 데코레이터의 인수로 관리된다. @Controller 데코레이터에도 인수를 전달하여 라우팅 경로의 접두어를 지정할 수 있다. 예를 들어 @Controller(‘app’)이라고 하면 http://localhost:3000/app/hello 로 접근된다. 라우팅 패스는 와일드 카드를 이용하여 작성할 수 있다. @Get(‘/he*lo’) 로 설정하면 hello, helo, he_o 등으로 접근가능하고, * 외 ?, +, () 역시 정규 표현식에서의 와일드 카드와 동일하게 동작한다. 단, -, . 은 문자열로 취급한다. 1.2 요청 객체 Nest는 요청과 함께 전달되는 데이터를 핸들러가 다룰 수 있는 객체로 변환한다. 이 객체는 @Req 데코레이터로 다룰 수 있다. app.controller.ts import { Controller, Get, Req } from '@nestjs/common'; import { AppService } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(@Req() req: Request): string { console.log(req); return this.appService.getHello(); } } 1.3 응답 요청의 성공 응답 코드는 POST일 경우 201이고, 나머지는 모두 200이다. Nest는 응답을 어떤 방식으로 처리할지 미리 정의해두었다. 객체를 리턴한다면 직렬화를 통해 JSON으로 자동 변환해준다. @Res 데코레이터를 이용해서 응답 객체를 다룰 수 있다. @Get() findAll(@Res() res) { const users = this.usersService.findAll(); return res.status(200).send(users); } 응답 코드를 변경하고 싶을때는 @HttpCode로 변경할수 있다. import { HttpCode } from '@nestjs/common'; @HttpCode(202) @Get() findAll() { return this.usersService.findAll(); } 예외 처리로 에러 코드를 보낼때는 아래처럼 정의된 Exception 객체들을 사용해서 처리한다. @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 1.4 헤더 Nest는 헤더를 자동으로 구성해준다. 만약 커스텀 헤더를 추가하고 싶다면 @Header 데코레이터를 사용하면 된다. 인수로 헤더 이름과 값을 받는다. @Header('Custom', 'Test Header') @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 1.5 리디렉션 클라이언트를 다른 페이지로 이동하고 싶은 경우 @Redirect 데코레이터를 사용해 구현할수 있다. 두번째 인자는 상태 코드이다. @Redirect('https://google.com', 301) @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 요청 결과에 따라 동적으로 리디렉트할 때는 응답으로 다음 객체를 리턴하면 된다. { \"url\": string, \"statusCode\": number } 예를 들어 다음처럼 구현할 수 있다. @Get('redirect/docs') @Redirect('https://docs.nestjs.com', 302) getDocs(@Query('version') version) { if (version &amp;&amp; version === '5') { return { url: 'https://docs.nestjs.com/v5/'}; } } 1.6 라우트 매개변수 전달받은 매개변수는 함수 인수에 @Param 데코레이터 주입받을 수 있다. @Delete(':userId/memo/:memoId') deleteUserMemo( @Param('userId') userId: string, @Param('memoId') memoId: string, ) { return `userId: ${userId}, memoId: ${memoId}`; } 1.7 하위 도메인 라우팅 http://example.com, http://api.example.com 각 들어온 요청을 다르게 처리하고 싶을때 사용한다. 먼저 새로운 컨트롤러를 생성한다. $ nest g co Api ApiController가 먼저 처리되도록 라우팅 순서를 변경한다. @Module({ imports: [UsersModule], controllers: [ApiController, AppController], providers: [AppService], }) export class AppModule {} @Controller 데코레이터는 ControllerOptions 객체를 인수로 받는데, host 속성에 하위 도메인을 기술하면 된다. @Controller({ host: \"api.localhost\" }) // 하위 도메인 요청 처리 설정 export class ApiController { @Get() // 같은 루트 경로 index(): string { return \"Hello Api\"; // 다른 응답 } } @HostParam 데코레이터를 통해 서브 도메인을 변수로 받을 수 있다. @Controller({ host: \":version.api.localhost\" }) export class ApiController { @Get() index(@HostParam(\"version\") version: string): string { return `Hello, API ${version}`; } } 1.9 페이로드 다루기 NestJS에서는 데이터 전송 객체 (DTO)가 구현되어 있어 body를 쉽게 다룰 수 있다. 회원 가입 처리를 위해 이름과 이메일을 추가해보자. create-user.dto.ts export class CreateUserDto { name: string; email: string; } users.controller.ts @Post() create(@Body() createUserDto: CreateUserDto) { const { name, email } = createUserDto; return `Created User. name: ${name}, Email: ${email}`; } 2. 유저 서비스의 인터페이스 이 과정에서는 다음과 같이 요청에 대한 인터페이스를 정의한다. 기능 end-point body(json) path parameter response 회원 가입 POST /users { “name”: “assu”, email”: “email@test.com”, “password”: “abcd” }   201 이메일 인증 POST /users/email-verify { “signupVerifyToken”: “fdsafdsa”   201 AccessToken 로그인 POST /users/login { “email”: “email@test.com”, “password”: “fdsafd” }   201 AccessToken 회원 정보 조회 GET /users/:id   id 200 회원 정보 먼저 컨트롤러를 만든다. $ nest g co users 회원 가입 인터페이스 구현 users.controller.ts import { Body, Controller, Post } from \"@nestjs/common\"; import { CreateUserDto } from \"./dto/create-user.dto\"; @Controller(\"users\") export class UsersController { @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { console.log(dto); } } dto/create-user.dto.ts export class CreateUserDto { readonly name: string; readonly email: string; readonly password: string; } 나머지 인터페이스 구현 users.controller.ts import { Body, Controller, Get, Param, Post, Query } from \"@nestjs/common\"; import { CreateUserDto } from \"./dto/create-user.dto\"; import { VerifyEmailDto } from \"./dto/verify-email.dto\"; import { UserLoginDto } from \"./dto/user-login.dto\"; import { UserInfo } from \"./UserInfo\"; @Controller(\"users\") export class UsersController { // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { console.log(\"createUser dto: \", dto); } // 이메일 인증 @Post(\"/email-verify\") async verifyEmail(@Query() dto: VerifyEmailDto): Promise&lt;string&gt; { console.log(\"verifyEmail dto: \", dto); return; } // 로그인 @Post(\"login\") async login(@Body() dto: UserLoginDto): Promise&lt;string&gt; { console.log(\"login dto: \", dto); return; } // 회원 정보 조회 @Get(\":id\") async getUserInfo(@Param(\"id\") userId: string): Promise&lt;UserInfo&gt; { console.log(\"getUserInfo userId: \", userId); return; } } dto/verify-email.dto.ts export class VerifyEmailDto { signupVerifyToken: string; } dto/user-login.dto.ts export class UserLoginDto { email: string; password: string; } UserInfo.ts 유저 정보는 다음과 같은 인터페이스로 구성된다. export interface UserInfo { id: string; name: string; email: string; } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/24/nest-interface/"
  },{
    "title": "[NestJs] Decorator",
    "text": "1. 설정 2. 사용 예시 3. Decorator Factory 4. Decorator 합성 5. Decorator 역할 요약 Nest는 Decorator를 적극 활용한다. Decorator를 잘 사용하면 횡단 관심사를 분리하여 관점 지향 프로그래밍을 적용한 코드를 작성할 수 있다. 타입스크립트의 Decorator는 클래스, 메서드, 접근자, 프로퍼티, 매개변수에 적용 가능하다. 각 요소의 선언부 앞에 @로 시작하는 Decorator를 선언하면 구현된 코드가 함께 실행된다. 1. 설정 Decorator를 사용하려면 tsconfig.json의 experimentalDecorators 옵션을 true로 활성화해야 한다. tsconfig.json { \"compilerOptions\": { \"target\": \"ES5\", \"experimentalDecorators\": true } } 2. 사용 예시 function deco( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"Decorator 가 평가됨\"); } class TestClass { @deco test() { console.log(\"test 함수 호출\"); } } const t = new TestClass(); t.test(); &gt; Decorator 가 평가됨 &gt; test 함수 호출 3. Decorator Factory 만약 Decorator 에 인수를 넘기고 싶다면 Decorator Factory, 즉 Decorator를 리턴하는 함수를 만들면 된다. function deco(value: string) { console.log(\"Decorator 평가됨\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(value); }; } class TestClass { @deco(\"Hello\") test() { console.log(\"함수 호출됨\"); } } const t = new TestClass(); t.test(); &gt; Decorator 평가됨 &gt; Hello &gt; 함수 호출됨 4. Decorator 합성 여러 개의 Decorator를 사용한다면 다음과 같이 선언한다. 각 표현은 위에서 아래로 평가된다. 결과는 아래에서 위로 함수를 호출한다. function first() { console.log(\"first(): factory evaluated\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"first(): called\"); }; } function second() { console.log(\"second(): factory evaluated\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"second(): called\"); }; } class ExampleClass { @first() @second() method() {} } &gt; first(): factory evaluated &gt; second(): factory evaluated &gt; second(): called &gt; first(): called 5. Decorator 역할 요약 Decorator 역할 전달 인수 선언 불가능 위치 Class Decorator 클래스의 정의를 읽거나 수정 constructor d.ts 파일, declare 클래스 Method Decorator 메서드의 정의를 읽거나 수정 target, propertyKey, propertyDescriptor d.ts 파일, declare 클래스, 오버로드 메서드 Accessor Decorator 접근자의 정의를 읽거나 수정 target, propertyKey, propertyDescriptor d.ts 파일, declare 클래스 Property Decorator 속성의 정의를 읽거나 수정 target, propertyKey d.ts 파일, declare 클래스 Parameter Decorator 매개변수의 정의를 읽음 target, propertyKey, parameterIndex d.ts 파일, declare 클래스 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/23/nest-decorator/"
  },{
    "title": "[NestJs] NestJs 장점 및 설치",
    "text": "1. NestJS 장점 2. NestJS 설치 3. NestJS 보일러플레이트 4. 서버 실행 1. NestJS 장점 NestJS는 Express 또는 Fastify 프레임워크를 래핑하여 동작한다. Fastify는 Express보다 벤치마크 결과 2배 빠른 속도를 자랑한다. NestJS는 Fastify의 빠른 속도와 Express의 높은 호환성을 갖고자 한다. Node.js 의 과도한 유연함으로 인해 발생하는 문제점을 해결하기 위해 데이터베이스. 객체 관계 매핑(ORM), 설정, 유효성 검사 등의 기능을 기본으로 제공한다. 그러면서도 필요한 라이브러리를 쉽게 설치하여 사용하는 Node.JS 장점은 그대로 가지고 있다. 모듈/컴포넌트 기반으로 프로그램을 작성함으로써 재사용성을 높인다. 또 제어 반전, 의존성 주입, 관점 지향 프로그래밍 같은 객체 지향 개념을 도입했다. 기본으로 타입스크립트를 채택하고 있다. 2. NestJS 설치 Mac 버전으로 설명한다. NodeJS 먼저 설치한다. https://nodejs.org/en @nestjs/cli 를 npm으로 설치한다. $ npm i -g @nestjs/cli 프로젝트를 생성한다. $ nest new project-name 3. NestJS 보일러플레이트 ├── README.md ├── nest-cli.json ├── package-lock.json ├── package.json ├── src │ ├── app.controller.spec.ts │ ├── app.controller.ts │ ├── app.module.ts │ ├── app.service.ts │ └── main.ts ├── test │ ├── app.e2e-spec.ts │ └── jest-e2e.json ├── tsconfig.build.json └── tsconfig.json 4. 서버 실행 $ npm i $ npm run start:dev [5:51:40 PM] Starting compilation in watch mode... [5:51:41 PM] Found 0 errors. Watching for file changes. [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [NestFactory] Starting Nest application... [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [InstanceLoader] AppModule dependencies initialized +10ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [RoutesResolver] AppController {/}: +4ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [RouterExplorer] Mapped {/, GET} route +2ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [NestApplication] Nest application successfully started +2ms localhost에서 구동된 것을 확인할 수 있다. 포트는 기본으로 main.ts 에서 3000번으로 설정되어 있다. 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/23/nest-basic/"
  }]};
