var tipuesearch = {"pages": [{
    "title": "[NestJs] 클린 아키텍처",
    "text": "1. 클린 아키텍처 2. SOLID 객체 지향 설계 원칙 3. 유저 서비스에 클린 아키텍처 적용하기 3.1 도메인 레이어 3.2 어플리케이션 레이어 3.3 인터페이스 레이어 3.4 인프라 레이어 3.5 이메일 모듈 1. 클린 아키텍처 클린 아키텍처는 소프트웨어를 여러 동심원 레이어로 나누고 각 레이어에 있는 컴포넌트는 안쪽 원에 있는 컴포넌트에만 의존성을 가지게 한다. 따라서 안쪽 컴포넌트는 바깥 원에 독립적이다. 이 책에서는 클린 아키텍처를 4개의 레이어로 분류했다. Infrastructure : 외부에서 가져다 쓰는 컴포넌트를 배치한다. 예를 들어 데이터베이스, 이메일 전송, 다른 서비스와의 통신 프로토콜 구현체 등 외부에서 제공하는 인터페이스나 라이브러리를 이용하여 우리 서비스에 맞게 구현한 구현체가 포함된다. Interface : 서비스가 제공하는 인터페이스가 구현되는 레이어. 컨트롤러의 외부 요청 형식, 나가는 데이터의 형식 등을 정의한다. 마찬가지로 게이트웨이나 프레젠터 같은 컴포넌트도 외부와의 인터페이스를 담당한다. Application : 비즈니스 로직이 구현되는 레이어이다. 서비스 로직들이 여기 존재한다. Domain : 애플리케이션의 핵심 도메인을 구현하는 레이어이다. 도메인 레이어는 다른 레이어에 의존하지 않는다. 따라서 애플리케이션이 가져야 하는 핵심 요소만 가진다. 클린 아키텍처 작성시 의존성 역전 원칙을 이해해야 한다. 각 레이어는 의존성이 안쪽 원으로 향하는데 구현할때 안쪽 원에서 바깥쪽 원의 구현체가 필요한 경우가 많다. 그때 안쪽 레이어에서는 인터페이스를 정의하고 인터페이스를 구현한 구현체는 바깥 레이어에 둠으로써 해결할 수 있다. 2. SOLID 객체 지향 설계 원칙 SOLID는 로버트 C. 마틴이 객체 지향 언어로 소프트웨어를 설계할 때의 방법론을 정리한 것이다. SOLID를 적용하면 유지 보수와 확장이 쉬운 시스템을 만들 수 있다. SRP: 단일 책임 원칙 이 원칙의 더 정확한 정의는 클래스를 변경하는 이유는 오직 한 가지뿐이어야 한다는 것이다. 클래스를 비대하게 설계하지 말고 크기가 작고 적은 책임을 가지도록 작성해서 변경에 유연하게 대처할 수 있도록 한다. OCP : 개방-폐쇄 원칙 확장에는 열려있고 변경에는 닫혀 있어야 한다. 소프트웨어의 요구 사항이 추가되었다고 해서 기존의 소스 코드를 고쳐야 하면 안된다. 즉, 기능의 추가가 기존 코드에는 영향을 끼치지 않도록 하는 구조가 필요하다. 이는 인터페이스를 활용하여 달성할 수 있다. 기능이 구현체가 아닌 인터페이스에 의존하도록 한다. 추가 기능은 인터페이스를 추가한다. LSP : 리스코프 치환 원칙 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 변경 가능해야 한다. 상속 관계에서 자식 클래스의 인스턴스는 부모 클래스로 선언된 함수의 인수로 전달할 수 있다. 실제 동작하는 인스턴스는 인터페이스가 제공하는 기능을 구현한 객체이지만 인터페이스를 사용하는 다른 객체에도 전달할 수 있어야 한다. 따라서 실제 구현체인 자식 인스턴스는 언제든지 부모 또는 인터페이스가 제공해야 하는 기능을 제공하는 다른 구현체로 바꿀 수 있다. ISP : 인터페이스 분리 원칙 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다. 하나의 인터페이스에 의존하게 되면 인터페이스에 기능이 추가될 때 인터페이스를 구현하는 모든 클래스를 수정해야 한다. 이보다는 인터페이스를 기능별로 잘게 쪼개어 특정 클라이언트용 인터페이스로 모아 사용하는 것이 변경에 대해 의존성을 낮추고 유연하게 대처할 수 있는 방법이다. DIP : 의존관계 역전 원칙 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다. 클린 아키텍처를 구현하기 위해서는 의존관계 역전이 발생하기 마련이고 이를 해소하기 위해 DI를 이용해야 한다. 이는 추후에 살펴본다. 3. 유저 서비스에 클린 아키텍처 적용하기 지금까지 레이어 없이 기능별 역할에 따라 Module로 분리했다. 이제 우리가 작성하고 있는 유저 서비스에서 유저 모듈로 그 범위를 좁혀 클린 아키텍처를 적용해보자. 먼저 다음과 같이 4개의 레이어와 모든 레이어에서 공통으로 사용하는 컴포넌트를 작성할 common 디렉터리를 만든다. /src/users ├── application ├── common ├── domain ├── infra ├── interface 3.1 도메인 레이어 가장 안쪽 레이어인 domain 레이어에는 도메인 객체와 그 도메인 객체의 상태 변화에 따라 발생되는 이벤트가 존재한다. UserModule은 User 도메인 객체를 갖는다. domain/user.ts export class User { constructor( private id: string, private name: string, private email: string, private password: string, private signupVarificationToken: string, ) {} } User 객체를 생성할 대 UserCreatedEvent 를 발송해야 한다. 이 도메인 이벤트를 발송하는 주체는 User의 생성자가 되어야 하는데 User 클래스는 new 키워드로 생성하므로 EventBus를 주입받을 수가 없다. 따라서 User를 생성하는 팩터리 클래스인 UserFactory를 구현해서 이를 프로바이더로 제공한다. domain/user.factory.ts import { EventBus } from '@nestjs/cqrs'; import { UserCreateEvent } from '../event/user-create.event'; import { User } from './user'; export class UserFactory { constructor(private eventBus: EventBus) {} create( id: string, name: string, email: string, signupVarificationToken: string, password: string, ) { const user = new User(id, name, email, password, signupVarificationToken); this.eventBus.publish(new UserCreateEvent(email, signupVarificationToken)); return user; } } users.module.ts ... import { UserFactory } from './domain/user.factory'; @Module({ ... providers: [ ... UserFactory, ], }) export class UsersModule {} UserCreatedEvent는 도메인 레이어에 위치시킨다. ├── domain │ ├── cqrs-event.ts │ ├── user-create.event.ts │ ├── user.factory.ts │ └── user.ts 3.2 어플리케이션 레이어 비즈니스 로직이 구현되는 application 레이어를 구현한다. UserEventsHandler를 어플리케이션 레이어로 이동하고 TestHandler는 삭제한다. application/user-event.handler.ts import { EventsHandler, IEventHandler } from '@nestjs/cqrs'; import { UserCreateEvent } from '../domain/user-create.event'; import { EmailService } from 'src/email/email.service'; @EventsHandler(UserCreateEvent) export class UserEventsHandler implements IEventHandler&lt;UserCreateEvent&gt; { constructor(private emailService: EmailService) {} async handle(event: UserCreateEvent) { switch (event.name) { case UserCreateEvent.name: { console.log('UserCreatedEvent!'); const { email, signupVerifyToken } = event as UserCreateEvent; await this.emailService.sendMemberJoinVerification( email, signupVerifyToken, ); break; } default: break; } } } 커맨드 핸들러도 application 레이어로 이동한다. 이때 커맨드와 이벤트 소스들을 따로 관리하고 싶다면 디렉터리를 따로 만드는 것도 좋다. ├── application │ ├── command │ │ ├── create-user.command.ts │ │ ├── create-user.handler.ts │ │ ├── login.command.ts │ │ ├── login.handler.ts │ │ ├── verify-email.command.ts │ │ └── verify-email.handler.ts │ ├── event │ │ └── user-event.handler.ts │ └── query │ ├── get-user-info.handler.ts │ └── get-user-info.query.ts 3.3 인터페이스 레이어 UsersController와 관계된 소스코드와 userInfo, DTO 관련 클래스들을 모두 interface 디렉터리로 이동한다. ├── interface │ ├── UserInfo.ts │ ├── dto │ │ ├── create-user.dto.ts │ │ ├── user-login.dto.ts │ │ └── verify-email.dto.ts │ └── users.controller.ts 3.4 인프라 레이어 유저 모듈에서 쓰는 외부 컴포넌트가 포함되도록 한다. 데이터베이스와 이메일 관련 로직이 대상이다. 먼저 엔티티 클래스를 infra/db/entity로 이동한다. UserEntity는 application 레이어에 있는 핸들러가 사용하고 있으므로 DIP를 적용해서 의존관계를 역전한다. 먼저 데이터베이스에 유저 정보를 다루는 인터페이스인 IUserRepository를 선언한다. 이는 domain 레이어에 작성한다. domain/repository/iuser.repository.ts import { User } from \"../user\"; export interface IUserRepository { findByEmail: (email: string) =&gt; Promise&lt;User | null&gt;; save: ( name: string, email: string, password: string, signupVerifyToken: string ) =&gt; Promise&lt;void&gt;; } IUserRepository의 구현체인 UserRepository는 infra 레이어에서 구현한다. infra/db/repository/user.repository.ts import { Injectable } from '@nestjs/common'; import { InjectRepository } from '@nestjs/typeorm'; import { IUserRepository } from 'src/users/domain/repository/iuser.repository'; import { Connection, Repository } from 'typeorm'; import { UserEntity } from '../entity/user.entity'; import { UserFactory } from 'src/users/domain/user.factory'; import { User } from 'src/users/domain/user'; @Injectable() export class UserRepository implements IUserRepository { constructor( private connection: Connection, @InjectRepository(UserEntity) private userRepository: Repository&lt;UserEntity&gt;, private userFactory: UserFactory, ) {} async findByEmail(email: string): Promise&lt;User | null&gt; { const userEntity = await this.userRepository.findOne({ where: { email }, }); if (!userEntity) { return null; } const { id, name, signupVerifyToken, password } = userEntity; // create에는 UserCreateEvent 가 발생하기 때문에 이벤트가 제외된 reconstitute 를 생성하여 사용한다. return this.userFactory.reconstitute( id, name, email, signupVerifyToken, password, ); } async save( id: string, name: string, email: string, password: string, signupVerifyToken: string, ): Promise&lt;void&gt; { // CreateUserHandler에 있던 로직을 이관한다. await this.connection.transaction(async (manager) =&gt; { const user = new UserEntity(); user.id = id; user.name = name; user.email = email; user.password = password; user.signupVerifyToken = signupVerifyToken; await manager.save(user); }); } } 이제 다른 레이어에서 IUserRepository를 이용해 데이터를 다룰 수 있다. CreateUserHandler를 수정하자. application/event/create-user.handler.ts import { Inject, Injectable, UnprocessableEntityException, } from '@nestjs/common'; import { CommandHandler, ICommandHandler } from '@nestjs/cqrs'; import { CreateUserCommand } from '../command/create-user.command'; import * as uuid from 'uuid'; import { IUserRepository } from 'src/users/domain/repository/iuser.repository'; import { UserFactory } from 'src/users/domain/user.factory'; @Injectable() @CommandHandler(CreateUserCommand) export class CreateUserHandler implements ICommandHandler&lt;CreateUserCommand&gt; { constructor( // UserRepository 토큰을 이용하여 구현된 클래스를 주입받는다. @Inject('UserRepository') private userRepository: IUserRepository, private userFactory: UserFactory, ) {} async execute(command: CreateUserCommand) { const { name, email, password } = command; // userRepository로 user를 찾는다. const userExist = await this.userRepository.findByEmail(email); if (userExist) { throw new UnprocessableEntityException( '해당 이메일로는 가입할 수 없습니다.', ); } const id = uuid.v1(); const signupVerifyToken = uuid.v1(); await this.userRepository.save( id, name, email, password, signupVerifyToken, ); this.userFactory.create(id, name, email, signupVerifyToken, password); } } users.module.ts ... import { UserRepository } from './infra/db/repository/user.repository'; @Module({ ... providers: [ ... // 커스텀 프로바이더로 주입한다. { provide: 'UserRepository', useClass: UserRepository }, ], }) export class UsersModule {} 3.5 이메일 모듈 이메일 모듈과 유저 모듈의 결합을 인터페이스로 느슨하게 변경한다. 이메일 모듈은 외부 시스템이기 때문에 infra 에 구현체를 위치시킨다. 또 이 구현체를 사용하는 곳은 UserEventsHandler인데 application 레이어에 존재한다. 따라서 application 레이어에 IEmailService를 정의한다. application/adapter/iemail.service.ts export interface IEmailService { sendMemberJoinVerification: ( email: string, signupVerifyToken: string ) =&gt; Promise&lt;void&gt;; } infra 레이어에 인터페이스의 구현체를 작성한다. infra/adapter/email.service.ts import { Injectable } from '@nestjs/common'; import { IEmailService } from 'src/users/application/adapter/iemail.service'; import { EmailService as ExternalEmailService } from 'src/email/email.service'; @Injectable() export class EmailService implements IEmailService { constructor(private emailService: ExternalEmailService) {} async sendMemberJoinVerification( email: string, signupVerifyToken: string, ): Promise&lt;void&gt; { this.emailService.sendMemberJoinVerification(email, signupVerifyToken); } } 이제 UserEventHandler에 IEmailService를 주입받아 사용하도록 변경한다. application/event/user-event.handler.ts import { EventsHandler, IEventHandler } from '@nestjs/cqrs'; import { UserCreateEvent } from '../../domain/user-create.event'; import { Inject } from '@nestjs/common'; import { IEmailService } from '../adapter/iemail.service'; @EventsHandler(UserCreateEvent) export class UserEventsHandler implements IEventHandler&lt;UserCreateEvent&gt; { constructor(@Inject('EmailService') private emailService: IEmailService) {} async handle(event: UserCreateEvent) { switch (event.name) { case UserCreateEvent.name: { console.log('UserCreatedEvent!'); const { email, signupVerifyToken } = event as UserCreateEvent; await this.emailService.sendMemberJoinVerification( email, signupVerifyToken, ); break; } default: break; } } } users.module.ts ... import { UserRepository } from './infra/db/repository/user.repository'; @Module({ ... providers: [ ... // 커스텀 프로바이더로 주입한다. { provide: 'UserRepository', useClass: UserRepository }, { provide: 'EmailService', useClass: EmailService }, ], }) export class UsersModule {} 나머지 핸들러도 동일하게 수정한다. 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/04/18-nest-clean-architecture/"
  },{
    "title": "[NestJs] CQRS",
    "text": "1. CQRS 패턴 2. 유저 서비스에 CQRS 적용하기 2.1 커맨드 2.2 이벤트 2.3 쿼리 1. CQRS 패턴 CQRS (command query responsibility separation) 패턴은 Command와 Query를 분리하여 성능, 확장성, 보안성을 높이는 아키텍처 패턴인다. 데이터를 조회한 쪽에서는 현재의 복잡한 모델 구조의 데이터가 필요하지 않은 경우가 많기 때문에 조회 시의 모델과 데이터를 업데이트할 때의 모델을 다르게 가져가도록 하는 방식이다. CQRS를 사용하면 복잡성이 추가되므로 모델을 공유하는 것이 도메인을 다루기 더 쉬운지 판단해야 한다. CQRS를 사용하면 읽기 및 쓰기 작업에서 로드를 분리하여 각각을 독립적으로 확장할 수 있다. 성능을 위해 쓰기는 RDB로 읽기는 Document DB를 사용하는 경우가 많습니다. 앱에서 읽기와 쓰기 사이에 성능 차이가 큰 경우 CQRS를 쓰면 좋다. 이벤트 기반 프로그래밍 모델과 잘 맞다. 이벤트 소싱을 쉽게 활용할 수 있다. 복잡한 도메인을 다루고 DDD를 적용하는 데 적합하다. 2. 유저 서비스에 CQRS 적용하기 nest에서 cqrs 패키지를 설치한다. $ npm i @nestjs/cqrs CQRS 모듈을 UserModule로 가지고 온다. users.module.ts ... import { CqrsModule } from '@nestjs/cqrs'; @Module({ imports: [ ... CqrsModule, ], ... }) export class UsersModule {} 2.1 커맨드 CRUD에서 Read를 제외한 나머지는 커맨드를 이용하여 처리한다. 커맨드는 서비스 계층이나 컨트롤러, 게이트웨이에서 직접 발송할 수 있다. 전송한 커맨드는 커맨드 핸들러가 받아서 처리한다. 유저 생성을 위한 커맨드를 정의한다. create-user.command.ts import { ICommand } from '@nestjs/cqrs'; export class CreateUserCommand implements ICommand { constructor( readonly name: string, readonly email: string, readonly password: string, ) {} } 컨트롤러에서 커맨드를 전달하도록 한다. users.controller.ts ... @Controller('users') export class UsersController { constructor( @Inject(WINSTON_MODULE_NEST_PROVIDER) private readonly logger: WinstonLogger, private userService: UsersService, private commandBus: CommandBus, ) {} // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { // this.printWinstonLog(dto); const { name, email, password } = dto; // await this.userService.createUser(name, email, password); const command = new CreateUserCommand(name, email, password); return this.commandBus.execute(command); } ... 이제 CreateUserHandler를 만든다. import { Injectable, UnprocessableEntityException } from '@nestjs/common'; import { CommandHandler, ICommandHandler } from '@nestjs/cqrs'; import { CreateUserCommand } from './create-user.command'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository, DataSource } from 'typeorm'; import { UserEntity } from './entity/user.entity'; import * as uuid from 'uuid'; @Injectable() @CommandHandler(CreateUserCommand) export class CreateUserHandler implements ICommandHandler&lt;CreateUserCommand&gt; { constructor( @InjectRepository(UserEntity) private userRepository: Repository&lt;UserEntity&gt;, private dataSource: DataSource, ) {} async execute(command: CreateUserCommand) { const { name, email, password } = command; const userExist = await this.checkUserExists(email); if (userExist) { throw new UnprocessableEntityException( '해당 이메일로는 가입할 수 없습니다.', ); } const signupVerifyToken = uuid.v1(); await this.saveUserUsingTransaction( name, email, password, signupVerifyToken, ); // await this.sendMemberJoinEmail(email, signupVerifyToken); } private async checkUserExists(email: string) { const user = await this.userRepository.findOne({ where: { email }, }); return user != undefined; // TODO: DB 연동 후 구현 } private async saveUserUsingTransaction( name: string, email: string, password: string, signupVerifyToken: string, ) { await this.dataSource.transaction(async (manager) =&gt; { const user = new UserEntity(); user.id = uuid.v1(); user.name = name; user.email = email; user.password = password; user.signupVerifyToken = signupVerifyToken; await manager.save(user); }); } } 이제 유저 이메일 검증 로직을 커맨드로 변경한다. verify-email.command.ts import { ICommand } from '@nestjs/cqrs'; export class CreateUserCommand implements ICommand { constructor(readonly signupVerifyToken: string) {} } users.controller.ts // 이메일 인증 @Post('/email-verify') async verifyEmail(@Query() dto: VerifyEmailDto): Promise&lt;string&gt; { const { signupVerifyToken } = dto; const command = new VerifyEmailCommand(signupVerifyToken); return this.commandBus.execute(command); } verify-email.handler.ts import { Injectable, NotFoundException } from '@nestjs/common'; import { CommandHandler, ICommandHandler } from '@nestjs/cqrs'; import { VerifyEmailCommand } from './verify-email.command'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository, DataSource } from 'typeorm'; import { UserEntity } from './entity/user.entity'; import { AuthService } from 'src/auth/auth.service'; @Injectable() @CommandHandler(VerifyEmailCommand) export class VerifyEmailHandler implements ICommandHandler&lt;VerifyEmailCommand&gt; { constructor( @InjectRepository(UserEntity) private userRepository: Repository&lt;UserEntity&gt;, private dataSource: DataSource, private authService: AuthService, ) {} async execute(command: VerifyEmailCommand): Promise&lt;any&gt; { const { signupVerifyToken } = command; const user = await this.userRepository.findOne({ where: { signupVerifyToken }, }); if (!user) { throw new NotFoundException('유저가 존재하지 않습니다.'); } return this.authService.login({ id: user.id, name: user.name, email: user.email, }); } } 이제 유저 로그인 로직을 커맨드로 구현한다. login.command.ts import { ICommand } from '@nestjs/cqrs'; export class LoginCommand implements ICommand { constructor( readonly email: string, readonly password: string, ) {} } users.controller.ts ... // 로그인 @Post('login') async login(@Body() dto: UserLoginDto): Promise&lt;string&gt; { const { email, password } = dto; const command = new LoginCommand(email, password); return this.commandBus.execute(command); } ... login.handler.ts import { Injectable, NotFoundException } from '@nestjs/common'; import { CommandHandler, ICommandHandler } from '@nestjs/cqrs'; import { InjectRepository } from '@nestjs/typeorm'; import { Repository } from 'typeorm'; import { UserEntity } from './entity/user.entity'; import { AuthService } from 'src/auth/auth.service'; import { LoginCommand } from './login.command'; @Injectable() @CommandHandler(LoginCommand) export class LoginHandler implements ICommandHandler&lt;LoginCommand&gt; { constructor( @InjectRepository(UserEntity) private userRepository: Repository&lt;UserEntity&gt;, private authService: AuthService, ) {} async execute(command: LoginCommand): Promise&lt;any&gt; { const { email, password } = command; const user = await this.userRepository.findOne({ where: { email, password }, }); if (!user) { throw new NotFoundException('유저가 존재하지 않습니다.'); } return this.authService.login({ id: user.id, name: user.name, email: user.email, }); } } users.module.ts ... @Module({ ... providers: [ CreateUserHandler, VerifyEmailHandler, LoginHandler, ], }) export class UsersModule {} 2.2 이벤트 회원 가입 중 이메일 전송하는 로직을 회원 가입과는 별개롤 다룰 수 있어야 한다. 또 별개로 전송되도록 비동기 처리되는 것이 응답을 더 빨리 수행할 수 있다. 이럴 경우 회원 가입 이벤트를 발생하고 이벤트를 구독하는 다른 모듈에서 이벤트를 처리하도록 한다. 회원 가입 이메일 전송 로직을 회원 가입 이벤트를 통해 처리하도록 한다. cqrs-event.ts export abstract class CqrsEvent { constructor(readonly name: string) {} } user-create.event.ts import { CqrsEvent } from './cqrs-event'; import { IEvent } from '@nestjs/cqrs'; export class UserCreateEvent extends CqrsEvent implements IEvent { constructor( readonly email: string, readonly signupVerifyToken: string, ) { super(UserCreateEvent.name); } } test.event.ts import { CqrsEvent } from \"./cqrs-event\"; import { IEvent } from \"@nestjs/cqrs\"; export class TestEvent extends CqrsEvent implements IEvent { constructor() { super(TestEvent.name); } } create-user.handler.ts ... constructor( ... private eventBus: EventBus, ) {} async execute(command: CreateUserCommand) { const { name, email, password } = command; const userExist = await this.checkUserExists(email); if (userExist) { throw new UnprocessableEntityException( '해당 이메일로는 가입할 수 없습니다.', ); } const signupVerifyToken = uuid.v1(); await this.saveUserUsingTransaction( name, email, password, signupVerifyToken, ); this.eventBus.publish(new UserCreateEvent(email, signupVerifyToken)); this.eventBus.publish(new TestEvent()); // await this.sendMemberJoinEmail(email, signupVerifyToken); } ... 이벤트 핸들러를 만들고 프로바이더로 제공해야 한다. event.handler.ts import { EventsHandler, IEventHandler } from '@nestjs/cqrs'; import { UserCreateEvent } from './user-create.event'; import { TestEvent } from './test.event'; import { EmailService } from 'src/email/email.service'; @EventsHandler(UserCreateEvent, TestEvent) export class UserEventsHandler implements IEventHandler&lt;UserCreateEvent | TestEvent&gt; { constructor(private emailService: EmailService) {} async handle(event: UserCreateEvent | TestEvent) { switch (event.name) { case UserCreateEvent.name: { console.log('UserCreatedEvent!'); const { email, signupVerifyToken } = event as UserCreateEvent; await this.emailService.sendMemberJoinVerification( email, signupVerifyToken, ); break; } case TestEvent.name: { console.log('TestEvent!'); break; } default: break; } } } users.module.ts ... import { UserEventsHandler } from './event.handler'; @Module({ ... providers: [ ... UserEventsHandler, ], }) export class UsersModule {} 2.3 쿼리 유저 정보 조회 부분을 쿼리로 분리한다. IQuery를 구현하는 쿼리 클래스와 IQueryHandler를 구현하는 쿼리 핸들러가 필요하다. 쿼리 핸들러는 @QueryHandler 데커레이터를 달아 주고 프로바이더로 등록한다. get-user-info.query.ts import { IQuery } from '@nestjs/cqrs'; export class GetUserInfoQuery implements IQuery { constructor(readonly userId: string) {} } get-user-info-query.handler.ts import { IQueryHandler, QueryHandler } from '@nestjs/cqrs'; import { GetUserInfoQuery } from './get-user-info.query'; import { InjectRepository } from '@nestjs/typeorm'; import { UserEntity } from './entity/user.entity'; import { Repository } from 'typeorm'; import { NotFoundException } from '@nestjs/common'; import { UserInfo } from './UserInfo'; @QueryHandler(GetUserInfoQuery) export class GetUserInfoQueryHandler implements IQueryHandler&lt;GetUserInfoQuery&gt; { constructor( @InjectRepository(UserEntity) private userRepository: Repository&lt;UserEntity&gt;, ) {} async execute(query: GetUserInfoQuery): Promise&lt;UserInfo&gt; { const { userId } = query; const user = await this.userRepository.findOne({ where: { id: userId }, }); if (!user) { throw new NotFoundException('유저가 존재하지 않습니다.'); } return { id: user.id, name: user.name, email: user.email, }; } } users.controller.ts @Controller('users') export class UsersController { constructor( ... private queryBus: QueryBus, ) {} ... // 회원 정보 조회 @UseGuards(AuthGuard) @Get(':id') async getUserInfo( @UserData() user: User, @Param('id') userId: string, ): Promise&lt;UserInfo&gt; { const getUserInfoQuery = new GetUserInfoQuery(userId); return this.queryBus.execute(getUserInfoQuery); } ... } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/03/17-nest-cqrs/"
  },{
    "title": "[NestJs] 태스크 스케줄링",
    "text": "1. @nestjs/schedule 패키지 2. 태스크 스케줄링을 선언하는 방식 2.1 크론 잡 선언 방식 2.2 인터벌 선언 방식 2.3 타임아웃 선언 방식 3. 동적 태스크 스케줄링 1. @nestjs/schedule 패키지 주기적으로 동일한 작업을 처리해야할 때 태스크 스케줄링을 통해 만들수 있다. Node.js에는 크론 기능을 하는 여러 라이브러리가 있고 Nestsms node-cron을 통합한 @nestjs/schedule 패키지를 제공한다. $ npm i --save @nestjs/schedule @types/cron 태스크 스케줄링은 ScheduleModule을 사용한다. 이 모듈을 AppModule에서 바로 사용해도 되지만 별도 모듈인 BatchModule에 작성한다. import { Module } from \"@nestjs/common\"; import { ScheduleModule } from \"@nestjs/schedule\"; import { TaskService } from \"./task.service\"; @Module({ imports: [ScheduleModule.forRoot()], providers: [TaskService], }) export class BatchModule {} 2. 태스크 스케줄링을 선언하는 방식 2.1 크론 잡 선언 방식 크론 잡 선언 방식은 @Cron 데커레이터를 선언한 메서드를 태스크로 구현하는 방식이다. import { Injectable, Logger } from '@nestjs/common'; import { Cron } from '@nestjs/schedule'; @Injectable() export class TaskService { private readonly logger = new Logger(TaskService.name); @Cron('* * * * * *', { name: 'cronTask' }) handleCron() { this.logger.log('Task Called!'); } } 2.2 인터벌 선언 방식 @Interval 데커레이터를 사용하여 인터벌로 스케줄링을 할 수 있다. import { Injectable, Logger } from '@nestjs/common'; import { Cron } from '@nestjs/schedule'; @Injectable() export class TaskService { private readonly logger = new Logger(TaskService.name); @Cron('* * * * * *', { name: 'cronTask' }) handleCron() { this.logger.log('Task Called!'); } @Interval('intervalTask', 3000) // 앱 실행 후 3초 후에 처음 수행되며, 3초마다 반복 handleInterval() { this.logger.log('Task Called!'); } } 2.3 타임아웃 선언 방식 앱이 실행된 후 태스크를 단 한번만 수행한다. @Timeout 데커레이터를 사용한다. import { Injectable, Logger } from '@nestjs/common'; import { Cron } from '@nestjs/schedule'; @Injectable() export class TaskService { private readonly logger = new Logger(TaskService.name); @Cron('* * * * * *', { name: 'cronTask' }) handleCron() { this.logger.log('Task Called!'); } @Interval('intervalTask', 3000) // 앱 실행 후 3초 후에 처음 수행되며, 3초마다 반복 handleInterval() { this.logger.log('Task Called!'); } @Timeout('timeoutTask', 5000) handleTimeout() { this.logger.log('Task called by timeout'); } } 3. 동적 태스크 스케줄링 앱 구동 중 특정 조건을 만족했을 때 태스크를 등록하도록 해보자. 이를 위해서는 태스크를 등록/해제할 방법이 필요하다. 동적 태스크 스케줄링은 SchedulerRegistry에서 제공하는 API를 사용한다. import { Injectable, Logger } from '@nestjs/common'; import { SchedulerRegistry } from '@nestjs/schedule'; import { CronJob } from 'cron'; @Injectable() export class TaskService { private readonly logger = new Logger(TaskService.name); constructor(private schedulerRegistry: SchedulerRegistry) { this.addCronJob(); } addCronJob() { const name = 'cronSample'; const job = new CronJob('* * * * * *', () =&gt; { this.logger.warn(`run! ${name}`); }); this.schedulerRegistry.addCronJob(name, job); this.logger.warn(`job ${name} added!!`); } } 이 상태에서는 아무런 동작을 하지 않는다. 등록된 크론 잡을 스케줄링으로 동작시키고 중지하는 기능을 가진 컨트롤러를 추가해보자. import { Controller, Post } from '@nestjs/common'; import { SchedulerRegistry } from '@nestjs/schedule'; @Controller('batches') export class BatchController { constructor(private scheduler: SchedulerRegistry) {} @Post('/start') start() { const job = this.scheduler.getCronJob('cronSample'); job.start(); console.log('start!! ', job.lastDate()); } @Post('/stop') stop() { const job = this.scheduler.getCronJob('cronSample'); job.stop(); console.log('stop!! ', job.lastDate()); } } import { Module } from \"@nestjs/common\"; import { ScheduleModule } from \"@nestjs/schedule\"; import { TaskService } from \"./task.service\"; import { BatchController } from \"./batch.controller\"; @Module({ imports: [ScheduleModule.forRoot()], providers: [TaskService], controllers: [BatchController], }) export class BatchModule {} 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/03/16-nest-cron/"
  },{
    "title": "[NestJs] 헬스 체크",
    "text": "1. Terminus 적용 2. 헬스 체크 3. TypeOrm 헬스 체크 4. 커스텀 상태 표시기 장애는 어느 레이어에스든 발생할 수 있다. 현재 서비스 상태를 체크할 장치가 필요하고 이를 헬스 체크라고 부른다. 서버는 HTTP, DB, 메모리, 디스크 상태 등을 체크하는 헬스 체크 장치가 있어야 한다. 만약 서버 상태에 문제가 있다면 이를 사내 메신저 등을 통해 즉시 담당자에게 알려야 한다. Nest 는 Terminus(@nestjs/terminus) 헬스 체크 라이브러리를 제공한다. 이는 다양한 상태 표시기를 제공하며 필요하면 직접 만들어서 사용할 수도 있다. 1. Terminus 적용 패키지를 설치한다. $ npm i @nestjs/terminus 상태 확인은 특정 라우터 엔드포인트로 요청을 보내고 응답을 확인하는 방법을 사용한다. 이를 위해 HealthCheckController 를 생성한다. TerminusModule과 생성한 컨트롤러를 실행할 수 있도록 준비한다. $ nest g controller health-check app.module.ts ... import { TerminusModule } from '@nestjs/terminus'; @Module({ imports: [ ,,, TerminusModule, ], controllers: [HealthCheckController], providers: [], }) ... 2. 헬스 체크 HttpHealthIndicator는 동작 과정에서 @nestjs/axios가 필요하므로 설치한다. $ npm i @nestjs/axios app.module.ts ... import { TerminusModule } from '@nestjs/terminus'; import { HttpModule } from '@nestjs/axios'; @Module({ imports: [ ,,, TerminusModule, HttpModule ], controllers: [HealthCheckController], providers: [], }) ... 컨트롤러에 HTTP 헬스 체크 코드를 구현한다. health-check.controller.ts import { Controller, Get } from '@nestjs/common'; import { HealthCheckService, HttpHealthIndicator } from '@nestjs/terminus'; @Controller('health-check') export class HealthCheckController { constructor( private health: HealthCheckService, private http: HttpHealthIndicator, ) {} @Get() check() { return this.health.check([ () =&gt; this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'), // 서비스가 제공하는 다른 서버가 잘 동작하는지 확인 ]); } } 3. TypeOrm 헬스 체크 TypeOrmHealthIndicator는 DB 가 잘 살아 있는지 확인한다. import { Controller, Get } from '@nestjs/common'; import { HealthCheckService, HttpHealthIndicator, TypeOrmHealthIndicator, } from '@nestjs/terminus'; @Controller('health-check') export class HealthCheckController { constructor( private health: HealthCheckService, private http: HttpHealthIndicator, private db: TypeOrmHealthIndicator, ) {} @Get() check() { return this.health.check([ () =&gt; this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'), () =&gt; this.db.pingCheck('database'), ]); } } 4. 커스텀 상태 표시기 @nestjs/terminus에서 제공하지 않는 상태 표시기가 필요하다면 HealthIndicator를 상속받는 상태 표시기를 직접 만든다. export declare abstract class HealthIndicator { /** * Generates the health indicator result object * @param key The key which will be used as key for the result object * @param isHealthy Whether the health indicator is healthy * @param data Additional data which will get appended to the result object */ protected getStatus(key: string, isHealthy: boolean, data?: { [key: string]: any; }): HealthIndicatorResult; } 예를 들어 강아지들의 상태를 알려주는 DogHealthIndicator라는 상태 표시기를 구현해보자. import { Injectable } from '@nestjs/common'; import { HealthCheckError, HealthIndicator, HealthIndicatorResult, } from '@nestjs/terminus'; export interface Dog { name: string; type: string; } @Injectable() export class DogHealthIndicator extends HealthIndicator { private dogs: Dog[] = [ { name: 'Fido', type: 'goodboy' }, { name: 'Rex', type: 'badboy' }, ]; async isHealthy(key: string): Promise&lt;HealthIndicatorResult&gt; { const badboys = this.dogs.filter((dog) =&gt; dog.type === 'badboy'); const isHealthy = badboys.length === 0; const result = this.getStatus(key, isHealthy, { badboys: badboys.length }); if (isHealthy) { return result; } throw new HealthCheckError('Dogcheck failed', result); } } app.module.ts ... import { DogHealthIndicator } from './health-check/dog-health.indicator'; @Module({ ... providers: [DogHealthIndicator], }) ... health-check.controller.ts import { Controller, Get } from '@nestjs/common'; import { HealthCheckService, HttpHealthIndicator, TypeOrmHealthIndicator, } from '@nestjs/terminus'; import { DogHealthIndicator } from './dog-health.indicator'; @Controller('health-check') export class HealthCheckController { constructor( private health: HealthCheckService, private http: HttpHealthIndicator, private db: TypeOrmHealthIndicator, private dogHealth: DogHealthIndicator, ) {} @Get() check() { return this.health.check([ () =&gt; this.http.pingCheck('nestjs-docs', 'https://docs.nestjs.com'), () =&gt; this.db.pingCheck('database'), () =&gt; this.dogHealth.isHealthy('dog'), ]); } } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/03/15-nest-health-check/"
  },{
    "title": "[NestJs] 인터셉터",
    "text": "1. 인터셉터 2. 응답과 예외 매핑 3. 유저 서비스에 인터셉터 적용하기 1. 인터셉터 인터셉터는 요청과 응답을 가로채서 변형을 할 수 있는 컴포넌트이다. 이를 이용하여 다음고 같은 기능을 수행할 수 있다. 매서드 실행 전/후 추가 로직 바인딩 함수에서 반환된 결과를 변환 함수에서 던져진 예외를 변환 기본 기능의 동작을 확장 특정 조건에 따라 기능을 완전히 재정의(예: 캐싱) 인터셉터는 미들웨어와 비슷하지만 수행 시점이 다르다. 미들웨어는 라우트 핸들러 전달 전에 동작하고 인터셉터는 라우트 핸들러의 전/후 호출된다. 라우트 핸들러가 요청 처리 전후 어떤 로그를 남기는 요구 사항이 있다면 LogginInterceptor를 만들어 처리할 수 있다. import { CallHandler, ExecutionContext, Injectable, NestInterceptor, } from \"@nestjs/common\"; import { Observable, tap } from \"rxjs\"; @Injectable() export class LoggingInterceptor implements NestInterceptor { intercept( context: ExecutionContext, next: CallHandler&lt;any&gt; ): Observable&lt;any&gt; | Promise&lt;Observable&lt;any&gt;&gt; { console.log(\"Before...\"); const now = Date.now(); return next .handle() .pipe(tap(() =&gt; console.log(`After... ${Date.now() - now} ms`))); } } 특정 컨트롤러나 메서드에 적용하고 싶다면 @UseInterceptors()를 이용하면 된다. 여기서는 전역으로 적용한다. main.ts import { NestFactory } from '@nestjs/core'; import { AppModule } from './app.module'; import { LoggingInterceptor } from './logging.interceptor'; async function bootstrap() { const app = await NestFactory.create(AppModule); ... app.useGlobalInterceptors(new LoggingInterceptor()); await app.listen(3000); } bootstrap(); NestInterceptor 인터페이스 export interface NestInterceptor&lt;T = any, R = any&gt; { /** * Method to implement a custom interceptor. * * @param context an `ExecutionContext` object providing methods to access the * route handler and class about to be invoked. * @param next a reference to the `CallHandler`, which provides access to an * `Observable` representing the response stream from the route handler. */ intercept( context: ExecutionContext, next: CallHandler&lt;T&gt; ): Observable&lt;R&gt; | Promise&lt;Observable&lt;R&gt;&gt;; } /** * Interface providing access to the response stream. * * @see [Interceptors](https://docs.nestjs.com/interceptors) * * @publicApi */ export interface CallHandler&lt;T = any&gt; { /** * Returns an `Observable` representing the response stream from the route * handler. */ handle(): Observable&lt;T&gt;; } CallHandler는 handle() 메서드를 구현해야한다. 이 메서드는 라우트 핸들러에서 전달된 응답 스트림을 리턴하고 RxJS의 Observable로 구현되어 있다. 인터셉터가 handle 메서드를 호출하지 않으면 라우터 핸들러가 동작을 하지 않는다. 2. 응답과 예외 매핑 전달받은 응답을 변형해보자. 라우터 핸들러에서 전달한 응답을 객체로 감싸서 전달하도록 하는 TransforInterceptor를 만든다. import { CallHandler, ExecutionContext, Injectable, NestInterceptor, } from \"@nestjs/common\"; import { Observable } from \"rxjs\"; import { map } from \"rxjs/operators\"; export interface Response&lt;T&gt; { data: T; } @Injectable() export class TransformInterceptor&lt;T&gt; implements NestInterceptor&lt;T, Response&lt;T&gt;&gt; { intercept( context: ExecutionContext, next: CallHandler&lt;T&gt; ): Observable&lt;Response&lt;T&gt;&gt; | Promise&lt;Observable&lt;Response&lt;T&gt;&gt;&gt; { return next.handle().pipe( map((data) =&gt; { return { data }; }) ); } } TransforInterceptor를 전역으로 적용해보자. useGlobalInterceptors에 인터셉터 객체를 추가한다. import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import { LoggingInterceptor } from \"./logging.interceptor\"; import { TransformInterceptor } from \"./transform.initerceptor\"; async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalInterceptors( new LoggingInterceptor(), new TransformInterceptor() ); await app.listen(3000); } bootstrap(); 라우트 핸들링 도중 던져진 예외를 잡아서 변환해보자. import { BadRequestException, CallHandler, ExecutionContext, Injectable, NestInterceptor, } from \"@nestjs/common\"; import { catchError, Observable, throwError } from \"rxjs\"; @Injectable() export class ErrorInterceptor implements NestInterceptor { intercept( context: ExecutionContext, next: CallHandler&lt;any&gt; ): Observable&lt;any&gt; | Promise&lt;Observable&lt;any&gt;&gt; { return next .handle() .pipe(catchError((err) =&gt; throwError(() =&gt; new BadRequestException()))); } } @UseInterceptors(ErrorInterceptor) @Get(':id') findOne(@Param('id') id: string) { throw new InternalServerErrorException(); } 3. 유저 서비스에 인터셉터 적용하기 유저 서비스에는 LoggingInterceptor를 변형하여 들어온 요청과 응답을 로그로 남겨본다. logging.interceptor.ts import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor, } from '@nestjs/common'; import { Observable, tap } from 'rxjs'; @Injectable() export class LoggingInterceptor implements NestInterceptor { constructor(private logger: Logger) {} intercept( context: ExecutionContext, next: CallHandler&lt;any&gt;, ): Observable&lt;any&gt; | Promise&lt;Observable&lt;any&gt;&gt; { const { method, url, body } = context.getArgByIndex(0); this.logger.log(`Request to ${method} ${url}`); return next.handle().pipe( tap((data) =&gt; { this.logger.log( `Response from ${method} ${url} \\n response: ${JSON.stringify(data)}`, ); }), ); } } LoggingInterceptor를 LoggingModule로 분리하여 적용한다. logger.module.ts import { Logger, Module } from \"@nestjs/common\"; import { APP_INTERCEPTOR } from \"@nestjs/core\"; import { LoggingInterceptor } from \"src/logger/logging.interceptor\"; @Module({ providers: [ Logger, { provide: APP_INTERCEPTOR, useClass: LoggingInterceptor }, ], }) export class LoggerModule {} app.module.ts ... @Module({ imports: [ ... LoggerModule, ], controllers: [], providers: [], }) ... 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/03/14-nest-interceptor/"
  },{
    "title": "[NestJs] 예외 처리",
    "text": "1. 예외 처리 2. 예외 필터 3. 유저 서비스에 예외 필터 적용하기 에러 처리기를 따로 만들어 한곳에서 공통으로 처리하도록 한다. 1. 예외 처리 Nest는 프레임워크 내에 예외 레이어를 두고 있다. import { InternalServerErrorException } from '@nestjs/common'; @Controller() export class AppController { @Get('/error') error(fooL any): string { return foo.bar(); } } { \"statusCode\": 500, \"message\": \"Internal Server Error\" } 에러 발생 시 응답을 JSON 형식으로 빠궈서 보내주는데 내장된 전역 예외 필터가 이를 처리한다. HttpException은 Error 객체로부터 파생되어 있다. Nest에서 제공하는 모든 Exception은 HttpException을 상속하고 있다. 2. 예외 필터 Nest에서 제공하는 전역 예외 필터 외에 직접 예외 필터 레이어를 두어서 원하는 대로 예외를 다룰 수 있다. 예외가 발생했을 때 로그를 남기거나 응 답 객체를 원하는 대로 변경하고자 하는 등의 요구 사항을 해결하고자 할 때 사용한다. import { ArgumentsHost, Catch, ExceptionFilter, HttpException, InternalServerErrorException, } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch() // 처리되지 않은 모든 예외를 잡을 때 사용 export class HttpExceptionFilter implements ExceptionFilter { catch(exception: any, host: ArgumentsHost): any { const ctx = host.switchToHttp(); const res = ctx.getResponse&lt;Response&gt;(); const req = ctx.getRequest&lt;Request&gt;(); if (!(exception instanceof HttpException)) { exception = new InternalServerErrorException(); } const response = (exception as HttpException).getResponse(); const log = { timestamp: new Date(), url: req.url, response, }; console.log(log); res.status((exception as HttpException).getStatus()).json(response); } } 예외 필터는 @UseFilter 데커레이터로 컨트롤러에 직접 적용하거나 전역으로 적용할 수 있다. 예외 필터는 전역 필터를 하나만 가지도록 하는 것이 일반적이다. 전역으로 적용 import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import { HttpExceptionFilter } from \"./http-exception.filter\"; async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalFilters(new HttpExceptionFilter()); await app.listen(3000); } bootstrap(); 부트스트랩에서 전역 필터를 적용하면 필터에 의존성을 주입할 수 없다는 제약이 있다. 의존성 주입을 받고자 한다면 예외 필터를 커스텀 프로바이더로 등록한다. 외부 모듈에서 제공하는 Logger 객체를 사용한다면 다음과 같이 구현한다. ... import { Logger } from '@nestjs/common'; import { APP_FILTER } from '@nestjs/core'; import { HttpExceptionFilter } from './http-exception.filter'; @Module({ providers: [ Logger, { provide: APP_FILTER, useClass: HttpExceptionFilter, }, ], }) export class AppModule {} @Catch() export class HttpExceptionFilter implements ExceptionFilter { constructor(private logger: Logger) { } } 3. 유저 서비스에 예외 필터 적용하기 앞서 만든 HttpExceptionFilter와 LoggerService를 사용한다. HttpExceptionFilter는 Logger를 주입받아 사용한다. 먼저 예외 처리를 위한 ExceptionModule을 생성한다. exception.module.ts import { Logger, Module } from \"@nestjs/common\"; import { APP_FILTER } from \"@nestjs/core\"; import { HttpExceptionFilter } from \"./http-exception.filter\"; @Module({ providers: [Logger, { provide: APP_FILTER, useClass: HttpExceptionFilter }], }) export class ExceptionModule {} http-exception.filter.ts import { ArgumentsHost, Catch, ExceptionFilter, HttpException, InternalServerErrorException, Logger, } from '@nestjs/common'; import { Request, Response } from 'express'; @Catch() export class HttpExceptionFilter implements ExceptionFilter { constructor(private logger: Logger) {} catch(exception: any, host: ArgumentsHost): any { const ctx = host.switchToHttp(); const res = ctx.getResponse&lt;Response&gt;(); const req = ctx.getRequest&lt;Request&gt;(); if (!(exception instanceof HttpException)) { exception = new InternalServerErrorException(); } const response = (exception as HttpException).getResponse(); const stack = exception.stack; const log = { timestamp: new Date(), url: req.url, response, stack, }; this.logger.log(log); res.status((exception as HttpException).getStatus()).json(response); } } app.module.ts ... @Module({ imports: [ ... ExceptionModule, ], controllers: [], providers: [], }) ... 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/03/13-nest-exception/"
  },{
    "title": "[NestJs] 로깅",
    "text": "1. 내장 로거 1.1 로깅 비활성화 1.2 로그 레벨 지정 2. 커스텀 로거 2.1 커스텀 로거 주입 2.2 커스텀 로거 전역 사용 3. 유저 서비스에 winston 외부 로거 적용하기 3.1 nest-winston 적용 3.2 내장 로거 대체하기 3.3 부트스래핑까지 포함하여 내장 로거 대체 Nest 로깅 옵션을 조절하면 다음과 같은 로깅 시스템의 동작을 제어할 수 있다. 로깅 비활성화 로그 레벨 지정: log, error, warn, debug, verbose 로거의 타임스탬프 재정의 기본 로거 재정의 기본 로거 확장을 통한 커스텀 로거 의존성 주입을 통한 로거 주입 및 테스트 모듈 제공 1. 내장 로거 내장 로거 인스턴스를 직접 생성하여 사용할 수 있다. import { Injectable, Logger } from '@nestjs/common'; @Injectable() export class AppService { // 로거 인스턴스 생성 시 클래스명을 컨텍스트로 설정하여 로그 메시지 앞에 클래스명이 함께 출력되도록 함. private readonly logger = new Logger(AppService.name); getHello(): string { this.logger.error('this is error'); this.logger.warn('this is warn'); this.logger.log('this is log'); this.logger.verbose('this is verbose'); this.logger.debug('this is debug'); return 'Hello World!'; } } 1.1 로깅 비활성화 아래와 같이 logger 옵션을 false로 하면 로그가 출력되지 않는다. main.ts ... async function bootstrap() { //const app = await NestFactory.create(AppModule); // 로그 비활성화 const app = await NestFactory.create(AppModule, { logger: false, }); await app.listen(3000); } ... 1.2 로그 레벨 지정 프로덕션 환경에서는 debug 로그가 남지 않도록 한다. 이를 동적으로 지정한다. async function bootstrap() { //const app = await NestFactory.create(AppModule); // 로그 비활성화 const app = await NestFactory.create(AppModule, { logger: process.env.NODE_ENV === \"prod\" ? [\"error\", \"warn\", \"log\"] : [\"debug\"], }); await app.listen(3000); } 2. 커스텀 로거 로그를 저장하는 기능을 내장 로거는 제공하지 않는다. 이를 위해서는 커스텀 로거를 만들어야 한다. 커스텀 로거는 LoggerService 인터페이스를 구현한다. export interface LoggerService { log(message: any, ...optionalParams: any[]): any; error(message: any, ...optionalParams: any[]): any; warn(message: any, ...optionalParams: any[]): any; debug?(message: any, ...optionalParams: any[]): any; verbose?(message: any, ...optionalParams: any[]): any; setLogLevels?(levels: LogLevel[]): any; } 커스텀 MyLogger를 만들어보자. import { LoggerService } from '@nestjs/common'; export class MyloggerService implements LoggerService { debug(message: any, ...optionalParams: any[]): any { console.log(message); } error(message: any, ...optionalParams: any[]): any { console.log(message); this.doSomething(); } private doSomething() { // DB 저장과 같은 부가 로직 추가 } log(message: any, ...optionalParams: any[]): any { console.log(message); } verbose(message: any, ...optionalParams: any[]): any { console.log(message); } warn(message: any, ...optionalParams: any[]): any { console.log(message); } } 2.1 커스텀 로거 주입 로거를 매번 생성해서 사용하는 것이 아니라 모듈로 만들어서 생성자에서 주입바아 사용한다. 먼저 LoggerModule을 만들고 AppModule에 가지고 온다. import { Module } from \"@nestjs/common\"; import { MyloggerService } from \"./mylogger.service\"; @Module({ providers: [MyloggerService], exports: [MyloggerService], }) export class LoggerModule {} ... import { LoggerModule } from './logging/logger.module'; @Module({ imports: [LoggerModule], ... }) export class AppModule {} 프로바이더로 MyLogger를 주입받아 사용한다. import { Injectable } from '@nestjs/common'; import { MyloggerService } from './logging/mylogger.service'; @Injectable() export class AppService { constructor(private myLogger: MyloggerService) {} getHello(): string { this.myLogger.error('test'); return 'Hello World!'; } } 2.2 커스텀 로거 전역 사용 main.ts import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import { MyloggerService } from \"./logging/mylogger.service\"; async function bootstrap() { const app = await NestFactory.create(AppModule); app.useLogger(app.get(MyloggerService)); await app.listen(3000); } bootstrap(); 3. 유저 서비스에 winston 외부 로거 적용하기 nodejs 의 winston 을 nest 용으로 만든 패키지인 nest-winston을 사용한다. 3.1 nest-winston 적용 nest-winston 을 설치한다. $ npm i nest-winston winston AppModule에 WinstonModule을 import 한다. 이때 winston 옵션을 줄 수 있다. app.module.ts ... import { WinstonModule, utilities } from 'nest-winston'; import * as winston from 'winston'; ... @Module({ imports: [ ... WinstonModule.forRoot({ transports: [ new winston.transports.Console({ level: process.env.NODE_ENV === 'production' ? 'info' : 'silly', format: winston.format.combine( winston.format.timestamp(), // 로그 시각 표시 utilities.format.nestLike('MyApp', { // 어디에서 로그를 남겼는지 구분하는 appName('MyApp') 설정 prettyPrint: true, }), ), }), ], }), ... winston이 지원하는 로그 레벨은 다음과 같다. 설정된 로그 레벨보다 레벨이 높은 로그는 함께 출력된다. { error: 0, warn: 1, info: 2, http: 3, verbose: 4, debug: 5, silly: 6 } WINSTON_MODULE_PROVIDER 토큰으로 Logger 객체를 주입받을 수 있다. users.controller.ts ... import { Logger as WinstonLogger } from 'winston'; import { WINSTON_MODULE_PROVIDER } from 'nest-winston'; ... export class UsersController { constructor( @Inject(WINSTON_MODULE_PROVIDER) private readonly logger: WinstonLogger, private userService: UsersService, ) {} ... private printWinstonLog(dto) { this.logger.error('error: ', dto); this.logger.warn('warn: ', dto); this.logger.info('info: ', dto); this.logger.http('http: ', dto); this.logger.verbose('verbose: ', dto); this.logger.debug('debug: ', dto); this.logger.silly('silly: ', dto); } ... [MyApp] Error 2024. 3. 3. 오후 5:43:45 error: - { name: 'ga', email: 'gmin2i.y@gmail.com', password: '123456788hfds' } [MyApp] Warn 2024. 3. 3. 오후 5:43:45 warn: - { name: 'ga', email: 'gmin2i.y@gmail.com', password: '123456788hfds' } [MyApp] Info 2024. 3. 3. 오후 5:43:45 info: - { name: 'ga', email: 'gmin2i.y@gmail.com', password: '123456788hfds' } [MyApp] Http 2024. 3. 3. 오후 5:43:45 http: - { name: 'ga', email: 'gmin2i.y@gmail.com', password: '123456788hfds' } [MyApp] Verbose 2024. 3. 3. 오후 5:43:45 verbose: - { name: 'ga', email: 'gmin2i.y@gmail.com', password: '123456788hfds' } [MyApp] Debug 2024. 3. 3. 오후 5:43:45 debug: - { name: 'ga', email: 'gmin2i.y@gmail.com', password: '123456788hfds' } [MyApp] Silly 2024. 3. 3. 오후 5:43:45 silly: - { name: 'ga', email: 'gmin2i.y@gmail.com', password: '123456788hfds' } 3.2 내장 로거 대체하기 Nest가 시스템 로깅을 할 때 출력하는 로그와 직접 출력하고자 하는 로깅의 형식을 동일하게 할 수 있다. 먼저 main.ts에 전역 로거로 설정한다. main.ts ... import { WINSTON_MODULE_NEST_PROVIDER } from 'nest-winston'; async function bootstrap() { ... app.useLogger(app.get(WINSTON_MODULE_NEST_PROVIDER)); ... } bootstrap(); 로깅을 하고자 하는 곳에서 LoggerServicefmf WINSTON_MODULE_NEST_PROVIDER 토큰으로 주입받는다. users.controller.ts ... export class UsersController { constructor( @Inject(WINSTON_MODULE_NEST_PROVIDER) private readonly logger: WinstonLogger, private userService: UsersService, ) {} ... // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { this.printLoggerServiceLog(dto); const { name, email, password } = dto; await this.userService.createUser(name, email, password); } ... private printLoggerServiceLog(dto) { try { throw new InternalServerErrorException('test'); } catch (e) { this.logger.error('error: ' + JSON.stringify(dto), e.stack); } this.logger.warn('warn: ', JSON.stringify(dto)); this.logger.log('log: ', JSON.stringify(dto)); this.logger.verbose('verbose: ', JSON.stringify(dto)); this.logger.debug('debug: ', JSON.stringify(dto)); } } [MyApp] Error 2024. 3. 3. 오후 5:54:07 error: {\"name\":\"ga\",\"email\":\"gmin22i.y@gmail.com\",\"password\":\"123456788hfds\"} - { stack: [ 'InternalServerErrorException: test\\n' + ' at UsersController.printLoggerServiceLog (/Users/jimimyeon/Documents/workspace/nest-basic-project/src/users/users.controller.ts:82:13)\\n' + ' at UsersController.createUser (/Users/jimimyeon/Documents/workspace/nest-basic-project/src/users/users.controller.ts:39:10)\\n' + ' at /Users/jimimyeon/Documents/workspace/nest-basic-project/node_modules/@nestjs/core/router/router-execution-context.js:38:29\\n' + ' at processTicksAndRejections (node:internal/process/task_queues:95:5)\\n' + ' at /Users/jimimyeon/Documents/workspace/nest-basic-project/node_modules/@nestjs/core/router/router-execution-context.js:46:28\\n' + ' at /Users/jimimyeon/Documents/workspace/nest-basic-project/node_modules/@nestjs/core/router/router-proxy.js:9:17' ] } [MyApp] Warn 2024. 3. 3. 오후 5:54:07 [{\"name\":\"ga\",\"email\":\"gmin22i.y@gmail.com\",\"password\":\"123456788hfds\"}] warn: [MyApp] Info 2024. 3. 3. 오후 5:54:07 [{\"name\":\"ga\",\"email\":\"gmin22i.y@gmail.com\",\"password\":\"123456788hfds\"}] log: [MyApp] Verbose 2024. 3. 3. 오후 5:54:07 [{\"name\":\"ga\",\"email\":\"gmin22i.y@gmail.com\",\"password\":\"123456788hfds\"}] verbose: [MyApp] Debug 2024. 3. 3. 오후 5:54:07 [{\"name\":\"ga\",\"email\":\"gmin22i.y@gmail.com\",\"password\":\"123456788hfds\"}] debug: nest-winston 모듈이 적용되어 MyAPP 태그가 붙어있다. 3.3 부트스래핑까지 포함하여 내장 로거 대체 이 부분은 책보다 간단하게 설정하는 방법은 NestFactory.create 에 bufferLogs를 true 로 주면 된다. (블로그 참고) import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import { ValidationPipe } from \"@nestjs/common\"; import { WINSTON_MODULE_NEST_PROVIDER } from \"nest-winston\"; async function bootstrap() { const app = await NestFactory.create(AppModule, { bufferLogs: true }); app.useGlobalPipes(new ValidationPipe({ transform: true })); app.useLogger(app.get(WINSTON_MODULE_NEST_PROVIDER)); await app.listen(3000); } bootstrap(); 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/03/12-nest-logger-copy/"
  },{
    "title": "[NestJs] 권한 확인을 위한 가드",
    "text": "1. 가드 2. 가드를 이용한 인가 2.1 실행 콘텍스트 (ExecutionContext) 2.2 가드 적용 3. 유저 서비스의 이메일 인증 처리와 JWT 발급 3.1 회원 가입 이메일 인증 3.2 JWT 인증 3.3 가드를 이용한 인가 처리 4. 커스텀 매개변수 데커레이터 4.1 유저 정보 추출 커스텀 데커레이터 1. 가드 인증은 요청자가 자신이 누구인지 증명하는 과정이다. 최근에는 JWT 토큰을 헤더에 실어 보내고 이 토큰을 통해 인증을 진행한다. 인가는 인증을 통과한 유저가 사용할 권한이 있는지 판별한다. 미들웨어는 ExecutionContext에 접근할 수 없어 다음 핸들러를 알 수 없으므로 가드를 이용하여 구현한다. 2. 가드를 이용한 인가 가드는 CanActivate 인터페이스를 구현한다. import { CanActivate, ExecutionContext } from '@nestjs/common'; import { Observable } from 'rxjs'; export class AuthGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { const request = context.switchToHttp().getRequest(); return this.validateRequest(request); } private validateRequest(request: any) { return true; } } 2.1 실행 콘텍스트 (ExecutionContext) canActivate 함수는 ExecutionContext 인스턴스를 인수로 받는다. ExecutionContext는 ArgumentsHost를 상속받는데, 요청과 응답에 대한 정보를 가지고 있다. swtichToHttp() 함수를 사용하여 필요한 정보를 가져올 수 있다. canActivate(context: ExecutionContext): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt;; export interface ExecutionContext extends ArgumentsHost { getClass&lt;T = any&gt;(): Type&lt;T&gt;; getHandler(): Function; } export interface ArgumentsHost { getArgs&lt;T extends Array&lt;any&gt; = any[]&gt;(): T; getArgByIndex&lt;T = any&gt;(index: number): T; switchToRpc(): RpcArgumentsHost; switchToHttp(): HttpArgumentsHost; switchToWs(): WsArgumentsHost; getType&lt;TContext extends string = ContextType&gt;(): TContext; } export interface HttpArgumentsHost { getRequest&lt;T = any&gt;(): T; getResponse&lt;T = any&gt;(): T; getNext&lt;T = any&gt;(): T; } 2.2 가드 적용 컨트롤러 범위 또는 메서드 범위로 적용하고자 한다면 @UseGuards(AuthGuard) 와 같이 사용하면 된다. AuthGuard 인스턴스 생성은 Nest가 한다. import { Controller, Get, UseGuards } from '@nestjs/common'; import { AppService } from './app.service'; import { AuthGuard } from './auth.guard'; @UseGuards(AuthGuard) // 클래스에 가드 적용 @Controller() export class AppController { constructor(private readonly appService: AppService) {} @UseGuards(AuthGuard) // 메서드에 가드 적용 @Get() getHello(): string { return this.appService.getHello(); } } 전역 가드는 bootstrap 에서 수행한다. async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalGuards(new AuthGuard()); // 전역 가드 적용 await app.listen(3000); } bootstrap(); 가드에 종속성 주입을 사용해서 다른 프로바이더를 주입해서 사용하고자 한다면 커스텀 프로바이더로 선언해서 사용한다. import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { APP_GUARD } from \"@nestjs/core\"; import { AuthGuard } from \"./auth.guard\"; @Module({ imports: [], controllers: [AppController], providers: [ AppService, { provide: APP_GUARD, useClass: AuthGuard, }, ], }) export class AppModule {} 세션, 토큰 인증과 JWT 관련 내용은 각자 학습하기를 바란다. 3. 유저 서비스의 이메일 인증 처리와 JWT 발급 3.1 회원 가입 이메일 인증 회원 가입 요청 시 발송된 이메일 인증을 통해 회원 가입을 완료하고, 요청 응답으로 토큰을 발급하여 로그인 상태가 되도록 한다. JWT 토큰 발급 및 검증을 위해 jsonwebtoken 패키지를 사용한다. $ npm i jsonwebtoken $ npm i --save-dev @types/jsonwebtoken JWT secret을 config를 통해 할당하기 위해 ConfigModule에 등록해준다. config/authConfig.ts import { registerAs } from \"@nestjs/config\"; export default registerAs(\"auth\", () =&gt; ({ jwtSecret: process.env.JWT_SECRET, })); config/env/.development.ts ... JWT_SECRET=secret app.module.ts ... @Module({ imports: [ UsersModule, ConfigModule.forRoot({ envFilePath: [`${__dirname}/config/env/.${process.env.NODE_ENV}.env`], load: [emailConfig, authConfig], isGlobal: true, validationSchema, }), ... AuthService에서 로그인 처리를 한다. 응답으로 JWT 토큰을 생성하여 리턴한다. $ nest g mo Auth $ nest g s Auth auth/auth.service.ts import { Inject, Injectable } from '@nestjs/common'; import { ConfigType } from '@nestjs/config'; import * as jwt from 'jsonwebtoken'; import authConfig from 'src/config/authConfig'; interface User { id: string; name: string; email: string; } @Injectable() export class AuthService { constructor( @Inject(authConfig.KEY) private config: ConfigType&lt;typeof authConfig&gt;, ) {} login(user: User) { const payload = { ...user }; return jwt.sign(payload, this.config.jwtSecret, { expiresIn: '1d', audience: 'example.com', issuer: 'example.com', }); } } AuthService를 UserService에서 사용하도록 export 해준다. import { Module } from \"@nestjs/common\"; import { AuthService } from \"./auth.service\"; @Module({ providers: [AuthService], exports: [AuthService], }) export class AuthModule {} users.module.ts import { Module } from \"@nestjs/common\"; import { UsersController } from \"./users.controller\"; import { UsersService } from \"./users.service\"; import { EmailModule } from \"src/email/email.module\"; import { TypeOrmModule } from \"@nestjs/typeorm\"; import { UserEntity } from \"./entity/user.entity\"; import { AuthService } from \"src/auth/auth.service\"; @Module({ imports: [EmailModule, TypeOrmModule.forFeature([UserEntity]), AuthModule], controllers: [UsersController], providers: [UsersService], }) export class UsersModule {} 이메일 검증 완료, 로그인 완료 시 authService의 login을 실행하여 JWT 를 리턴한다. users.service.ts ... import { AuthService } from 'src/auth/auth.service'; @Injectable() export class UsersService { constructor( private emailService: EmailService, private authService: AuthService, @InjectRepository(UserEntity) private userRepository: Repository&lt;UserEntity&gt;, private dataSource: DataSource, ) {} ... async login(email, password) { const user = await this.userRepository.findOne({ where: { email, password }, }); if (!user) { throw new NotFoundException('유저가 존재하지 않습니다.'); } return this.authService.login({ id: user.id, name: user.name, email: user.email, }); } ... async verifyEmail(signupVerifyToken: string): Promise&lt;string&gt; { const user = await this.userRepository.findOne({ where: { signupVerifyToken }, }); if (!user) { throw new NotFoundException('유저가 존재하지 않습니다.'); } return this.authService.login({ id: user.id, name: user.name, email: user.email, }); } ... 3.2 JWT 인증 클라이언트는 로그인 후 서버로부터 받은 JWT 를 저장한 후 리소스를 요철할 때 헤더로 함께 전달하는 것으로 가정한다. Bearer Token 은 OAuth2.0 스펙 RFC 6750에 정의돼 있지만 일반적인 용도로도 많이 사용된다. GET /users/:id Authorization: Bearer &lt;token&gt; auth.service.ts ... verify(jwtString: string) { try { const payload = jwt.verify(jwtString, this.config.jwtSecret) as ( | jwt.JwtPayload | string ) &amp; User; const { id, email } = payload; return { userId: id, email, }; } catch (e) { throw new UnauthorizedException(); } } ... users.controller.ts ... // 회원 정보 조회 @Get(':id') async getUserInfo( @Headers() headers: any, @Param('id') userId: string, ): Promise&lt;UserInfo&gt; { const jwtString = headers.authorization.split('Bearer ')[1]; this.authService.verify(jwtString); return await this.userService.getUserInfo(userId); } ... users.service.ts async getUserInfo(userId: string): Promise&lt;UserInfo&gt; { const user = await this.userRepository.findOne({ where: { id: userId }, }); if (!user) { throw new NotFoundException('유저가 존재하지 않습니다.'); } return { id: user.id, name: user.name, email: user.email, }; } 3.3 가드를 이용한 인가 처리 컨트롤러의 유저 정보 조회 구현을 모든 엔드포인트에 중복 구현하는 것은 매우 비효율적이며 DRY 원칙에도 위배된다. 앞서 예시로 만든 것과 같이 AuthGuard를 만들어보자. auth.guard.ts import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'; import { AuthService } from './auth.service'; import { Observable } from 'rxjs'; import { Request } from 'express'; @Injectable() export class AuthGuard implements CanActivate { constructor(private authService: AuthService) {} canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { const request = context.switchToHttp().getRequest(); return this.validateRequest(request); } private validateRequest(request: Request) { const jwtString = request.headers.authorization.split('Bearer ')[1]; this.authService.verify(jwtString); return true; } } 이를 회원 조회 엔드포인트에만 적용해보자. users.controller.ts ... // 회원 정보 조회 @UseGuards(AuthGuard) @Get(':id') async getUserInfo(@Param('id') userId: string): Promise&lt;UserInfo&gt; { return await this.userService.getUserInfo(userId); } ... 4. 커스텀 매개변수 데커레이터 4.1 유저 정보 추출 커스텀 데커레이터 @UserData 데커레이터를 만들어서 유저 정보를 추출해보자. auth.guard.ts import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common'; import { AuthService } from './auth.service'; import { Observable } from 'rxjs'; import { Request } from 'express'; @Injectable() export class AuthGuard implements CanActivate { constructor(private authService: AuthService) {} canActivate( context: ExecutionContext, ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; { const request = context.switchToHttp().getRequest(); const { name, userId, email } = this.validateRequest(request); request.user = { id: userId, name, email, }; return true; } private validateRequest(request: Request) { const jwtString = request.headers.authorization.split('Bearer ')[1]; return this.authService.verify(jwtString); } } userData.decorator.ts import { createParamDecorator, ExecutionContext } from '@nestjs/common'; export const UserData = createParamDecorator&lt;string&gt;( (data: string, ctx: ExecutionContext) =&gt; { const request = ctx.switchToHttp().getRequest(); const user = request.user; return data ? user?.[data] : user; }, ); users.controller.ts ... // 회원 정보 조회 @UseGuards(AuthGuard) @Get(':id') async getUserInfo( @UserData() user: User, @Param('id') userId: string, ): Promise&lt;UserInfo&gt; { console.log(user); return await this.userService.getUserInfo(userId); } ... 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/02/11-nest-guard/"
  },{
    "title": "[NestJs] 미들웨어",
    "text": "1. 미들웨어 2. Logger 미들웨어 3. MiddlewareConsumer 4. 전역으로 적용하기 1. 미들웨어 라우트 핸들러가 클라이언트 요청을 처리하기 전에 수행되는 컴포넌트를 말한다. Nest 미들웨어는 Express와 동일하며 다음 동작을 수행할 수 있다. 어떤 형태의 코드라도 수행할 수 있다. 요청과 응답에 변형을 가할 수 있다. 요청/응답 주기를 끝낼 수 있다. 여러 개의 미들웨어를 사용한다면 next()로 호출 스택상 다음 미들웨어에 제어권을 전달한다. 요청 응답 주기를 끝낸다는 것은 응답을 보내거나 에러 처리를 한다는 뜻이다. 미들웨어가 응답 주기를 끝내지 않을 것이라면 next()를 호출해야 한다. 미들웨어를 활용하여 다음과 같은 작업을들 수행한다. 쿠키 파싱 : 쿠키를 파싱하여 변경하여 핸들러에 전달 세션 관리 : 세션 상태를 조회해서 요청에 세션 정보를 추가한다. 인증/인가 : 사용자가 서비스에 접근 가능한 권한이 있는지 확인한다. Nest는 가드를 이용하도록 권장한다. 본문 파싱 : JSON, 파일 스트림 같은 데이터를 변환하여 매개변수에 넣는 작업을 한다. 커스텀 미들웨어도 구현할 수 있다. 예를 들어 데이터베이스 트랜잭션이 필요한 요청이 있을 때 트랜잭션을 걸고 동작 수행 완료 후 커밋하는 미들웨어를 사용할 수 있다. 비슷한 개념으로는 인터셉터가 있다. 2. Logger 미들웨어 미들웨어는 함수로 작성하거나 NestMiddleware 인터페이스를 구현한 클래스로 작성할 수 있다. logger.middleware.ts import { Injectable, NestMiddleware } from \"@nestjs/common\"; import { Request, Response, NextFunction } from \"express\"; @Injectable() export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: NextFunction) { console.log(\"Request...\"); next(); } } app.module.ts export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer.apply(LoggerMiddleware).forRoutes(\"/users\"); } } 3. MiddlewareConsumer configure 메서드에 인수로 전달된 MiddlewareConsumer 객체를 이용해서 미들웨어를 적용할 라우트를 관리할 수 있다. apply 메서드에 미들웨어를 콤마로 나열하면 미들웨어가 나열된 순서대로 적용된다. forRoutes 의 인수는 문자열 형식의 경로를 직접주거나, 컨트롤러 클래스 이름을 주어도 되고, RouteInfo 객체를 넘길 수도 있다. 보통은 클래스를 주어서 동작하도록 한다. export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer.apply(LoggerMiddleware).forRoutes(UsersController); } } exclude 는 미들웨어를 적용하지 않을 라우팅 경로를 설정한다. export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .exclude({ path: \"/users\", method: RequestMethod.GET }) .forRoutes(UsersController); } } 4. 전역으로 적용하기 미들웨어를 모든 모듈에 적용하기 위해서는 main.ts에서 NestFactory.create의 use() 메서드를 사용하여 미들웨어를 설정한다. import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import { ValidationPipe } from \"@nestjs/common\"; import { LoggerMiddleware } from \"./logger/logger.middleware\"; async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe({ transform: true })); app.use(LoggerMiddleware); await app.listen(3000); } bootstrap(); 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/02/10-nest-middleware/"
  },{
    "title": "[NestJs] 영속화 - 데이터베이스 다루기",
    "text": "1. MySQL 설정 2. TypeORM으로 데이터베이스 연결 3. 회원 가입 요청한 유저의 정보 저장 4. 트랜잭션 적용 4.1 QueryRunner 사용 4.2 transaction 함수 이용 5. 마이그레이션 이번 포스트에서는 MySQL과 TypeORM을 사용하여 데이터를 다루어보도록 한다. 1. MySQL 설정 MySQL 설치 및 실행은 아래 블로그를 확인하기 바란다. https://velog.io/@yeawonbong/MySQL 2. TypeORM으로 데이터베이스 연결 typeorm 라이브러리를 설치한다. $ npm i typeorm @nestjs/typeorm mysql2 TypeOrmModule을 이용하여 DB에 연결한다. app.module.ts import { Module } from \"@nestjs/common\"; import { UsersModule } from \"./users/users.module\"; import { ConfigModule } from \"@nestjs/config\"; import emailConfig from \"./config/emailConfig\"; import { validationSchema } from \"./config/validationSchema\"; import { TypeOrmModule } from \"@nestjs/typeorm\"; @Module({ imports: [ UsersModule, ConfigModule.forRoot({ envFilePath: [`${__dirname}/config/env/.${process.env.NODE_ENV}.env`], load: [emailConfig], isGlobal: true, validationSchema, }), // TypeOrmModule을 동적 모듈로 가지고 온다. TypeOrmModule.forRoot({ type: \"mysql\", // 데어터베이스 타입 host: \"localhost\", port: 3306, username: \"root\", password: \"test\", database: \"test\", entities: [__dirname + \"/**/*.entity{.ts,.js}\"], // 소스 코드 내에서 TypeORM이 구동될 때 인식하도록 할 엔티티 클래스 경로 synchronize: true, // 서비스 구동 시 소스 코드 기반으로 데이터베이스 스키마를 동기화할지 여부. 로컬에서만 true로 설정. }), ], controllers: [], providers: [], }) export class AppModule {} forRoot에 전달되는 TypeOrmModuleOptions 시그니처 export type TypeOrmModuleOptions = { /** * Number of times to retry connecting * Default: 10 */ retryAttempts?: number, /** * Delay between connection retry attempts (ms) * Default: 3000 */ retryDelay?: number, /** * Function that determines whether the module should * attempt to connect upon failure. * * @param err error that was thrown * @returns whether to retry connection or not */ toRetry?: (err: any) =&gt; boolean, /** * If `true`, entities will be loaded automatically. */ autoLoadEntities?: boolean, /** * If `true`, connection will not be closed on application shutdown. * @deprecated */ keepConnectionAlive?: boolean, /** * If `true`, will show verbose error messages on each connection retry. */ verboseRetryLog?: boolean, /** * If `true` database initialization will not be performed during module initialization. * This means that database connection will not be established and migrations will not run. * Database initialization will have to be performed manually using `DataSource.initialize` * and it will have to implement own retry mechanism (if necessary). */ manualInitialization?: boolean, } &amp; Partial&lt;DataSourceOptions&gt;; retryAttempts : 연결 시 재시도 횟수, 기본은 10 retryDelay : 재시도 간 지연시간, 기본 3000 ms toRetry : 에러 시 연결을 시도할 지 판단하는 함수. 콜백으로 받은 인수 err 을 이용하여 연결 여부를 판단하는 함수를 구현 autoLoadEntities : entity 를 자동으로 로드할 지 여부 keepConnectionAlive: 애플리케이션 종료 후 연결을 유지할 지 여부 verboseRetryLog : 연결 재시도 시 verbose 레벨로 에러 메시지를 보여줄 지 여부 TypeOrmModuleOptions는 위의 타입과 DataSourceOptions 타입을 교차한 타입. 이 옵션 외의 세부 옵션은 MysqlConnectionOptions를 살펴보아야 한다. TypeOrmModuleOptions 객체를 환경 변수에서 값을 읽어도록 변경. /config/env/.development.env ... DATABASE_HOST=localhost DATABASE_USERNAME=root DATABASE_PASSWORD=test DATABASE_SYNCHRONIZE=true app.module.ts ... @Module({ imports: [ ... // TypeOrmModule을 동적 모듈로 가지고 온다. TypeOrmModule.forRoot({ type: 'mysql', // 데어터베이스 타입 host: process.env.DATABASE_HOST, port: 3306, username: process.env.DATABASE_USERNAME, password: process.env.DATABASE_PASSWORD, database: 'test', entities: [__dirname + '/**/*.entity{.ts,.js}'], // 소스 코드 내에서 TypeORM이 구동될 때 인식하도록 할 엔티티 클래스 경로 synchronize: process.env.DATABASE_SYNCHRONIZE === 'true', // 서비스 구동 시 소스 코드 기반으로 데이터베이스 스키마를 동기화할지 여부. 로컬에서만 true로 설정. }), ], ... 3. 회원 가입 요청한 유저의 정보 저장 유저 엔티티 정의 src/users/entity/user.entity.ts import { Column, Entity, PrimaryColumn } from \"typeorm\"; @Entity(\"User\") export class UserEntity { @PrimaryColumn() id: string; @Column({ length: 30 }) name: string; @Column({ length: 60 }) email: string; @Column({ length: 30 }) password: string; @Column({ length: 60 }) signupVerifyToken: string; } 데이터베이스 사용하도록 함수 구현 users.module.ts import { Module } from \"@nestjs/common\"; import { UsersController } from \"./users.controller\"; import { UsersService } from \"./users.service\"; import { EmailModule } from \"src/email/email.module\"; import { TypeOrmModule } from \"@nestjs/typeorm\"; import { UserEntity } from \"./entity/user.entity\"; @Module({ imports: [EmailModule, TypeOrmModule.forFeature([UserEntity])], // UserEntity Repository 등록\u001f controllers: [UsersController], providers: [UsersService], }) export class UsersModule {} users.service.ts ... @Injectable() export class UsersService { constructor( private emailService: EmailService, @InjectRepository(UserEntity) private userRepository: Repository&lt;UserEntity&gt;, // inject repository ) {} ... users.service.ts ... async createUser( name: string, email: string, password: string, ): Promise&lt;void&gt; { const userExist = await this.checkUserExists(email); if (userExist) { throw new UnprocessableEntityException( '해당 이메일로는 가입할 수 없습니다.', ); } const signupVerifyToken = uuid.v1(); await this.saveUser(name, email, password, signupVerifyToken); await this.sendMemberJoinEmail(email, signupVerifyToken); } ... private async checkUserExists(email: string) { const user = await this.userRepository.findOne({ where: { email }, }); return user != undefined; // TODO: DB 연동 후 구현 } ... private async saveUser( name: string, email: string, password: string, signupVerifyToken: string, ) { const user = new UserEntity(); user.id = uuid.v1(); user.name = name; user.email = email; user.password = password; user.signupVerifyToken = signupVerifyToken; await this.userRepository.save(user); } ... 4. 트랜잭션 적용 트랜잭션은 요청을 처리하는 과정에서 데이터베이스에 변경이 일어나는 요청을 분리해서 에러 발생시 이전 상태로 되돌리게 하기 위해 데이터베이스에서 제공하는 기능이다. TypeORM에서 트랜잭션은 2가지 방법으로 사용할 수 있다. QueryRunner를 이용해서 DB 커넥션 상태 생성 및 관리 transaction 함수 사용 4.1 QueryRunner 사용 user.service.ts ... private async saveUserUsingQueryRunner( name: string, email: string, password: string, signupVerifyToken: string, ) { const queryRunner = this.dataSource.createQueryRunner(); // QueryRunner 생성 await queryRunner.connect(); // 연결 await queryRunner.startTransaction(); // 트랜잭션 시작 try { const user = new UserEntity(); user.id = uuid.v1(); user.name = name; user.email = email; user.password = password; user.signupVerifyToken = signupVerifyToken; await queryRunner.manager.save(user); // 저장 await queryRunner.commitTransaction(); // 커밋 } catch (e) { await queryRunner.rollbackTransaction(); // 에러 발생시 롤백 } finally { await queryRunner.release(); // 생성한 QueryRunner는 해제한다. } } ... 4.2 transaction 함수 이용 user.service.ts ... private async saveUserUsingTransaction( name: string, email: string, password: string, signupVerifyToken: string, ) { await this.dataSource.transaction(async (manager) =&gt; { const user = new UserEntity(); user.id = uuid.v1(); user.name = name; user.email = email; user.password = password; user.signupVerifyToken = signupVerifyToken; await manager.save(user); }); } ... 5. 마이그레이션 데이터베이스 스키마 변경시 마이그레이션을 한다. TypeORM에서 제공하는 마이그레이션을 사용하면 SQL 문을 직접 작성하지 않아도 되고 롤백 작업도 쉽게 수행할 수 있다. 먼저 ts-node 패키지를 글로벌 환경으로 설치해서 typeorm cli를 실행할 수 있게 한다. $ npm i -g ts-node pacakage.json 에 typeorm 실행 스크립트를 작성한다. \"scripts\": { ... \"typeorm:create\": \"ts-node -r ts-node/register ./node_modules/typeorm/cli.js\", \"typeorm:generate\": \"ts-node -r ts-node/register ./node_modules/typeorm/cli.js -d ormconfig.ts\" ... root에 ormconfig.ts 파일을 생성한다. ormconfig.ts import { DataSource } from \"typeorm\"; export const AppDataSource = new DataSource({ type: \"mysql\", host: \"localhost\", port: 13306, username: \"root\", password: \"password\", database: \"test\", entities: [__dirname + \"/**/*.entity{.ts,.js}\"], synchronize: false, migrations: [__dirname + \"/**/migrations/**/*{.ts,.js}\"], migrationsTableName: \"migrations\", }); tsconfig.json { ... \"include\": [\"src/**/*\"] ... } app.module.ts ... TypeOrmModule.forRoot({ type: 'mysql', // 데어터베이스 타입 host: process.env.DATABASE_HOST, port: 3306, username: process.env.DATABASE_USERNAME, password: process.env.DATABASE_PASSWORD, database: 'test', entities: [__dirname + '/**/*.entity{.ts,.js}'], // 소스 코드 내에서 TypeORM이 구동될 때 인식하도록 할 엔티티 클래스 경로 // synchronize: process.env.DATABASE_SYNCHRONIZE === 'true', // 서비스 구동 시 소스 코드 기반으로 데이터베이스 스키마를 동기화할지 여부. 로컬에서만 true로 설정. synchronize: false, // 마이그레이션 테스트를 위해 변경 migrationsRun: false, // 서버 구동 시 자동으로 마이그레이션 하지 않도록 설정. cli로만 직접 입력한다. migrations: [__dirname + '/**/migrations/*.js'], // 마이그레이션 스크립트 경로 migrationsTableName: 'migrations', // 마이그레이션 이력 기록되는 테이블 이름 }), ... User 테이블 삭제한 후 서버를 재시동한다. migration:create: 수행할 마이그레이션 내용이 비어 있는 파일 생성 migration:generate: 현재 소스 코드와 migrations 테이블에 기록된 이력을 기반으로 마이그레이션 파일 자동 생성 $ npm run typeorm migration:create src/migrations/CreateUserTable 아래와 같은 파일이 생성된다. import { MigrationInterface, QueryRunner } from \"typeorm\"; export class CreateUserTable1709375389995 implements MigrationInterface { // migration:run 수행 시 실행 public async up(queryRunner: QueryRunner): Promise&lt;void&gt; { } // migration:revert 수행 시 실행 public async down(queryRunner: QueryRunner): Promise&lt;void&gt; { } } migration 코드를 cli로 생성해보자. $ npm run typeorm:generate migration:generate src/migrations/CreateUserTable 아래와 같은 파일이 생성된다. import { MigrationInterface, QueryRunner } from 'typeorm'; export class CreateUserTable1709376266709 implements MigrationInterface { name = 'CreateUserTable1709376266709'; public async up(queryRunner: QueryRunner): Promise&lt;void&gt; { await queryRunner.query( `CREATE TABLE \\`User\\` (\\`id\\` varchar(255) NOT NULL, \\`name\\` varchar(30) NOT NULL, \\`email\\` varchar(60) NOT NULL, \\`password\\` varchar(30) NOT NULL, \\`signupVerifyToken\\` varchar(60) NOT NULL, PRIMARY KEY (\\`id\\`)) ENGINE=InnoDB`, ); } public async down(queryRunner: QueryRunner): Promise&lt;void&gt; { await queryRunner.query(`DROP TABLE \\`User\\``); } } 마이그레이션을 실행해보자. $ npm run typeorm:generate migration:run 마이그레이션을 되돌려보자. $ npm run typeorm:generate migration:revert 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/02/09-nest-database/"
  },{
    "title": "[NestJs] 파이프와 유효성 검사",
    "text": "1. 파이프 2. 파이프의 내부 구현 이해하기 3. 유효성 검사 파이프 만들기 4. 유저 서비스에 유효성 검사 적용 4.1 유저 생성 body 유효성 검사 4.2 class-transformer 활용 4.3 커스텀 유효성 검사기 1. 파이프 파이프는 요청이 라우터 핸들러로 전달되기 전에 요청 객체를 변환하거나 검사할 수 있게 한다. 미들웨어와 비슷하지만 파이프는 모든 context에서 사용할 수 있다. @nest/common 패키지에는 여러 내장 파이프가 있다. ValidationPipe ParseIntPipe ParseBoolPipe ParseArrayPipe ParseUUIDPipe DefaultValuePipe 예를 들어 /users/user/:id 엔드포인트에 전달된 id는 문자열 타입이다. 코드에서는 이를 정수로 사용할때 @Param 데커레이터를 통해 실행 context에 바인딩할 수 있다. @Get(':id') findOne(@Param('id', ParseIntPipe) id: number) { return this.userService.findOne(id); } ** id 에 정수 파싱이 안되는 문자를 전달하면 400 에러가 발생한다. ** 클래스를 전달하지 않고 파이프 객체를 직접 생성해서 전달할 수 있다. 예를 들어 에러에서 상태코드를 변경하고자 할때 사용할 수 있다. @Get(':id') findOne(@Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE })) id: number) { return this.userService.findOne(id); } DefaultValuePipe는 인수에 기본값을 설정할 때 사용한다. @Get() findAll( @Query('offset', new DefaultValuePipe(0), ParseIntPipe) offset: number, @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number, ) { console.log(offset, limit); return this.userService.findAll(); } 2. 파이프의 내부 구현 이해하기 Nest에서 ValidationPipe를 제공하지만 여기서 ValidationPipe를 직접 만들어본다. 커스텀 파이프는 PipeTransform 인터페이스를 상속받은 클래스에 @Injectable 데코레이터를 붙여준다. validation.pipe.ts import { PipeTransform, Injectable, ArgumentMetadata } from \"@nestjs/common\"; @Injectable() export class ValidationPipe implements PipeTransform { transform(value: any, metadata: ArgumentMetadata) { console.log(metadata); return value; } } value: 현재 파이프에 전달된 인수 metadata: 현재 파이프에 전달된 인수의 메타데이터 ArgumentMetadata 시그니처 export interface ArgumentMetadata { /** * Indicates whether argument is a body, query, param, or custom parameter */ readonly type: Paramtype; /** * Underlying base type (e.g., `String`) of the parameter, based on the type * definition in the route handler. */ readonly metatype?: Type&lt;any&gt; | undefined; /** * String passed as an argument to the decorator. * Example: `@Body('userId')` would yield `userId` */ readonly data?: string | undefined; } type: 파이프에 전달된 인수가 본문인지 쿼리 매개변수인지, 경로 매개변수인지 커스텀 매개변수인지 나타낸다. metadata: 라우트 핸들러에 정의된 인수의 타입을 알려준다. data: 데커레이터에 전달된 문자열, 즉, 매개변수의 이름이다. 예를 들어 아래 라우터 핸들러를 구현했다면, transform 함수에 전달되는 인수는 다음과 같은 객체가 된다. @Get(':id') findOne(@Param('id', ValidationPipe) id: number) { return this.userService.findOne(id); } { metadata: [Function: Number], type: 'param', data: 'id' } 3. 유효성 검사 파이프 만들기 Nest 공식 문서에는 @UsePipes와 joi 를 이용하여 커스텀 파이프를 바인딩하는 방법을 설명한다. joi는 널리 사용되지만 class-validator와 비교하면 문법이 번거롭다. class-validator를 이용하여 유효성 검사 파이프를 구현해보자. $ npm i --save class-validator class-transformer dto/create-user.dto import { IsEmail, IsString, MaxLength, MinLength } from 'class-validator'; export class CreateUserDto { @IsString() @MinLength(1) @MaxLength(20) readonly name: string; @IsEmail() email: string; } 위에서 정의한 dto 객체를 받아서 유효성 검사를 하는 파이프(ValidationPipe)를 직접 구현해보자. import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform, } from '@nestjs/common'; import { validate } from 'class-validator'; import { plainToClass } from 'class-transformer'; @Injectable() export class ValidationPipe implements PipeTransform&lt;any&gt; { async transform(value: any, { metatype }: ArgumentMetadata) { // metatype 이 지원하는 타입인지 검사 if (!metatype || !this.toValidate(metatype)) { return value; } // 순수 자바스크립트 객체를 클래스의 객체로 변환, class-validator의 유효성 검사는 타입이 필요하므로 타입 지정 과정을 plainToClass로 수행한다. const object = plainToClass(metatype, value); const errors = await validate(object); if (errors.length &gt; 0) { throw new BadRequestException('Validation failed~'); } return value; } private toValidate(metatype: Function): boolean { const types: Function[] = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); } } ValidationPipe 적용 @Post() create(@Body(ValidationPipe) createUserDto: CreateUserDto) { return this.userService.create(createUserDto) } 잘못된 데이터 전달하면 에러가 발생한다. { \"statusCode\": 400, \"message\": \"Validation failed\", \"error\": \"Bad Request\" } ValidationPipe를 전역 설정하기 위해서는 bootstrap에서 적용하면 된다. import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import { ValidationPipe } from \"./validation.pipe\"; async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000); } bootstrap(); 4. 유저 서비스에 유효성 검사 적용 4.1 유저 생성 body 유효성 검사 Nest 에서 제공하는 ValidationPipe를 전역으로 적용한다. 이때 class-tranformer를 적용하기 위해 transform 속성을 true로 설정한다. main.ts import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import { ValidationPipe } from \"@nestjs/common\"; async function bootstrap() { const app = await NestFactory.create(AppModule); app.useGlobalPipes(new ValidationPipe({ transform: true })); await app.listen(3000); } bootstrap(); DTO를 수정한다. create-user.dto.ts import { IsEmail, IsString, Matches, MaxLength, MinLength, } from 'class-validator'; export class CreateUserDto { @IsString() @MinLength(2) @MaxLength(20) readonly name: string; @IsString() @IsEmail() @MaxLength(60) readonly email: string; @IsString() @Matches(/^[A-Za-z\\d!@#$%^&amp;*()]{8,30}$/) readonly password: string; } 4.2 class-transformer 활용 @Transform 데커레이터는 transformFn를 인수로 받는다. transformFn은 value와 obj 등을 인수로 받아 속성을 변형한 후 리턴하는 함수이다. export declare function Transform(transformFn: (params: TransformFnParams) =&gt; any, options?: TransformOptions): PropertyDecorator; export interface TransformFnParams { value: any; key: string; obj: any; type: TransformationType; options: ClassTransformOptions; } name 속성에 @Transform 적용하여 값을 확인해보자. create-user.dto.ts import { Transform } from 'class-transformer'; import { IsEmail, IsString, Matches, MaxLength, MinLength, } from 'class-validator'; export class CreateUserDto { @Transform((params) =&gt; { console.log(params); return params.value; }) @IsString() @MinLength(2) @MaxLength(20) readonly name: string; ... { value: 'ga', key: 'name', obj: { name: 'ga', email: 'gmini.y@gmail.com', password: 'pasdfqwer' }, type: 0, options: { enableCircularCheck: false, enableImplicitConversion: false, excludeExtraneousValues: false, excludePrefixes: undefined, exposeDefaultValues: false, exposeUnsetFields: true, groups: undefined, ignoreDecorators: false, strategy: undefined, targetMaps: undefined, version: undefined } } name에 앞뒤 공백을 제거하는 로직을 추가하자. create-user.dto.ts ... export class CreateUserDto { @Transform((params) =&gt; params.value.trim()) @IsString() @MinLength(2) @MaxLength(20) readonly name: string; ... TransformFnParams의 obj는 CreateUserDto 객체를 갖는다. 이를 통해 password는 name과 동일한 문자열을 포함할 수 없도록 구현할 수 있다. @ create-user.dto.ts ... export class CreateUserDto { ... @Transform(({ value, obj }) =&gt; { if (obj.password.includes(obj.name.trim())) { throw new BadRequestException('password can not include string of name'); } return value.trim(); }) @IsString() @Matches(/^[A-Za-z\\d!@#$%^&amp;*()]{8,30}$/) readonly password: string; } ... 4.3 커스텀 유효성 검사기 직접 필요한 유효성 검사를 수행하는 데커레이터를 만들어서 활용할 수 있다. not-in.ts import { ValidationOptions, registerDecorator, ValidationArguments, } from 'class-validator'; // 데커레이터 인수는 참조하고자 하는 다른 속성의 이름과 ValidationOptions를 받는다. export function NotIn(property: string, validationOptions?: ValidationOptions) { // registerDecorator를 호출하는 함수를 리턴한다. // eslint-disable-next-line @typescript-eslint/ban-types return (object: Object, propertyName: string) =&gt; { // registerDecorator 함수는 ValidationDecoratorOptions 객체를 인수로 받는다. registerDecorator({ name: 'NotIn', // 데커레이터 이름 target: object.constructor, // 객체 생성 시 적용 propertyName, options: validationOptions, // 데커레이터 인수로 받은 옵션을 적용한다. constraints: [property], // 속성에 적용되도록 제약을 준다. validator: { // 유효성 검사 규칙이 기술된다. validate(value: any, args: ValidationArguments) { const [relatedPropertyName] = args.constraints; const relatedValue = (args.object as any)[relatedPropertyName]; return ( typeof value === 'string' &amp;&amp; typeof relatedValue === 'string' &amp;&amp; !relatedValue.includes(value) ); }, }, }); }; } create-user.dto.ts ... import { NotIn } from './not-in'; export class CreateUserDto { @Transform((params) =&gt; params.value.trim()) @NotIn('password', { message: 'password can not include name' }) @IsString() @MinLength(2) @MaxLength(20) readonly name: string; ... } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/03/02/08-nest-pipe-validation-check/"
  },{
    "title": "[TypeScript] 타입스크립트 설정",
    "text": "tsconfig.json을 통해 타입스크립트 옵션을 설정해야 동료들과 다른 도구들이 알 수 있다. { \"compilerOptions\": { \"module\": \"commonjs\", \"declaration\": true, \"removeComments\": true, \"emitDecoratorMetadata\": true, \"experimentalDecorators\": true, \"allowSyntheticDefaultImports\": true, \"target\": \"ES2021\", \"sourceMap\": true, \"outDir\": \"./dist\", \"baseUrl\": \"./\", \"incremental\": true, \"skipLibCheck\": true, \"strictNullChecks\": false, \"noImplicitAny\": false, \"strictBindCallApply\": false, \"forceConsistentCasingInFileNames\": false, \"noFallthroughCasesInSwitch\": false }, \"include\": [\"src/**/*\"] } noImplicitAny는 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다. 되도록이면 true로 설정해서 ‘implicit any’를 제거한다. strictNullChecks는 null과 undefined가 모든 타입에서 허용되는 지 확인한다. const x: number = null 은 strictNullChecks가 true면 오류가 발생한다. const x: number null = null 의도를 명시적으로 드러냄으로써 오류를 해결한다. null과 undefined 관련된 오류를 잡아 내는 데 도움이 되지만 코드 작성이 어렵다. 익숙한 사용자는 true를 사용하는 것이 좋지만 false로 설정해도 괜찮다. strictNullChecks 는 noImplictAny가 true이어야 한다. 타입스크립트에서 엄격한 체크를 하고 싶다면 strict 설정을 고려해보아야 한다. 본 포스트는 댄 밴더캄 저자의 이펙티브 타입스크립트를 기반으로 스터디하며 정리한 내용들입니다. 이펙티브 타입스크립트",
    "tags": "typescript dev",
    "url": "/dev/2024/03/02/02-typescript-item2/"
  },{
    "title": "[TypeScript] 타입스크립트와 자바스크립트",
    "text": "타입스크립트는 자바스크립트의 상위집합으로 모든 자바 스크립트 프로그램은 타입스크립트 프로그램이다. 반대로 타입스크립트는 별도의 문법을 가지고 있기 때문에 일반적으로는 유효한 자바스크립트 프로그램이 아니다. 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입시스템을 가지고 있기 때문에 런타임 오류를 발생시키는 코드를 찾아내려고 한다. 모든 오류를 찾아내리라 기대해서는 안된다. 타입 체커를 통과해도 런타임 오류를 발생시키는 코드는 많다. 잘못된 매개변수 개수로 함수를 호출하는 경우처럼, 자바스크립트에서는 허용되지만 타입스크립트에서는 허용하지 않는 경우가 있다. 문법적 엄격함은 취향의 차이이므로 타입스크립트를 쓸지 이를 고려하여 선택해야 한다. 본 포스트는 댄 밴더캄 저자의 이펙티브 타입스크립트를 기반으로 스터디하며 정리한 내용들입니다. 이펙티브 타입스크립트",
    "tags": "typescript dev",
    "url": "/dev/2024/03/02/01-typescript-item1/"
  },{
    "title": "[NestJs] 동적 모듈을 활용한 환경 변수 구성",
    "text": "1. 동적 모듈 2. dotenv를 이용한 Config 설정 3. Nest에서 제공하는 Config 패키지 4. 유저 서비스에 환경 변수 구성하기 4.1 커스텀 Config 파일 작성 4.2 동적 ConfigModule 등록 1. 동적 모듈 동적 모듈 (Dynamic Module) 은 모듈이 생성될 때 동적으로 변수들이 정해진다. 실행 환경에 따라 환경 변수를 관리하는 모듈인 Config 모듈이 대표적인 예다. 2. dotenv를 이용한 Config 설정 NodeJs의 dotenv 라이브러리를 통해 환경 변수를 설정한다. dotenv는 .env확장자를 가진 파일을 읽어서 환경 변수를 설정한다. dotenv를 설치하자. $ npm i dotenv $ npm i -D @types/dotenv dotenv는 루트 디렉터리에 있는 .env확장자 파일을 읽는다. DTABASE_HOST라는 환경 변수를 각 파일에 저자한다. .development.env DATABASE_HOST = local; .stage.env DATABASE_HOST = stage - reader.dextto.com; .production.env DATABASE_HOST = prod - reader.dextto.com; package.json 을 수정해서 NODE_ENV를 설정되도록 한다. package.json \"prebuild\": \"rimraf dist\", \"start:dev\": \"npm run prebuild &amp;&amp; NODE_ENV=local nest start --watch\", env 파일을 읽어서 사용하도록 변경한다. main.ts import { NestFactory } from \"@nestjs/core\"; import { AppModule } from \"./app.module\"; import * as dotenv from \"dotenv\"; import * as path from \"path\"; dotenv.config({ path: path.resolve( process.env.NODE_ENV === \"production\" ? \".production.env\" : process.env.NODE_ENV === \"stage\" ? \".stage.env\" : \".local.env\" ), }); async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000); } bootstrap(); 3. Nest에서 제공하는 Config 패키지 앞에서 dotenv 패키지를 직접 사용했는데 Nest는 dotenv를 내부적으로 활용하는 @nestjs/config 패키지를 제공한다. 이를 이용해서 ConfigModule을 동적으로 생성할 수 있다. $ npm i @nestjs/config 이 패키지에는 ConfigModule이 이미 존재한다. 이 모듈을 동적 모듈로 가지고 온다. app.module.ts import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { ConfigModule } from \"@nestjs/config\"; @Module({ imports: [ConfigModule.forRoot()], controllers: [AppController], providers: [AppService], }) export class AppModule {} forRoot는 DynamicModule을 리턴하는 정적 메서드로 ConfigModuleOptions를 인수로 받는다. forRoot() static forRoot(options?: ConfigModuleOptions): DynamicModule; ConfigModule은 소비 모듈이 원하는 옵션값을 전달하여 원하는 대로 동적으로 ConfigModule을 생성한다. ConfigModule export interface ConfigModuleOptions { /** * If \"true\", values from the process.env object will be cached in the memory. * This improves the overall application performance. * See: https://github.com/nodejs/node/issues/3104 */ cache?: boolean; /** * If \"true\", registers `ConfigModule` as a global module. * See: https://docs.nestjs.com/modules#global-modules */ isGlobal?: boolean; /** * If \"true\", environment files (`.env`) will be ignored. */ ignoreEnvFile?: boolean; /** * If \"true\", predefined environment variables will not be validated. */ ignoreEnvVars?: boolean; /** * Path to the environment file(s) to be loaded. */ envFilePath?: string | string[]; /** * Environment file encoding. */ encoding?: string; /** * Custom function to validate environment variables. It takes an object containing environment * variables as input and outputs validated environment variables. * If exception is thrown in the function it would prevent the application from bootstrapping. * Also, environment variables can be edited through this function, changes * will be reflected in the process.env object. */ validate?: (config: Record&lt;string, any&gt;) =&gt; Record&lt;string, any&gt;; /** * Environment variables validation schema (Joi). */ validationSchema?: any; /** * Schema validation options. * See: https://joi.dev/api/?v=17.3.0#anyvalidatevalue-options */ validationOptions?: Record&lt;string, any&gt;; /** * Array of custom configuration files to be loaded. * See: https://docs.nestjs.com/techniques/configuration */ load?: Array&lt;ConfigFactory&gt;; /** * A boolean value indicating the use of expanded variables, or object * containing options to pass to dotenv-expand. * If .env contains expanded variables, they'll only be parsed if * this property is set to true. */ expandVariables?: boolean | DotenvExpandOptions; } 루트 디렉터리에 있는 .env 파일을 환경 변수로 등록한다. app.module.ts import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { ConfigModule } from \"@nestjs/config\"; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: process.env.NODE_ENV === \"production\" ? \".production.env\" : process.env.NODE_ENV === \"stage\" ? \".stage.env\" : \".local.env\", }), ], controllers: [AppController], providers: [AppService, ConfigService], }) export class AppModule {} ConfigModule은 환경 변수 값을 가져오는 프로바이더인 ConfigService가 있다. 이를 원하는 컴포넌트에서 주입해서 사용하면 된다. import { Controller, Get } from '@nestjs/common'; import { ConfigService } from '@nestjs/config'; @Controller() export class AppController { constructor( private readonly configService: ConfigService, ) {} @Get('config') getConfig(): string { return this.configService.get('DATABASE_HOST'); } } 4. 유저 서비스에 환경 변수 구성하기 @nest/config 와 환경 변수 유효성 검사를 위한 joi를 설치한다. $ npm i @nestjs/config $ npm i joi .development.env EMAIL_SERVICE=Gmail EMAIL_AUTH_USER=YOUR-GAMIL EMAIL_AUTH_PASSWORD=YOUR-GMAIL-PASSWORD EMAIL_BASE_URL=http://localhost:3000 4.1 커스텀 Config 파일 작성 모든 환경 변수가 .env 파일에 선언되어 있지만, 가져다 쓸 대는 DatabaseConfig, EmailConfig와 같이 의미 있는 단위로 묶고 싶다면 ConfigModule을 이용해 구현할수 있다. src/config에 이메일 관련 환경 변수를 관리하는 emailConfig.ts를 작성한다. email 토큰으로 ConfigFactory를 등록하는 코드이다. emailConfig.ts import { registerAs } from \"@nestjs/config\"; export default registerAs(\"email\", () =&gt; ({ service: process.env.EMAIL_SERVICE, auth: { user: process.env.EMAIL_AUTH_USER, pass: process.env.EMAIL_AUTH_PASSWORD, }, baseUrl: process.env.EMAIL_BASE_URL, })); 4.2 동적 ConfigModule 등록 .env 파일을 루트 경로가 아니라 src/config/env 디렉터리에 모아서 관리한다. nest-cli.json { \"$schema\": \"https://json.schemastore.org/nest-cli\", \"collection\": \"@nestjs/schematics\", \"sourceRoot\": \"src\", \"compilerOptions\": { \"assets\": [ { \"include\": \"./config/env/*.env\", \"outDir\": \"./dist\" } ], \"watchAssets\": true // watch 모드에서 asset을 탐색하게 한다. } } AppModule에 ConfigModule을 등록한다. config는 전역모듈로 설정해서 모든 모듈에서 사용할 수 있게 한다. 유효성 검사를 위해 유효성 검사 객체를 작성한다. app.module.ts import { Module } from \"@nestjs/common\"; import { UsersModule } from \"./users/users.module\"; import { ConfigModule } from \"@nestjs/config\"; import emailConfig from \"./config/emailConfig\"; import { validateSchema } from \"./config/validateSchema\"; @Module({ imports: [ UsersModule, ConfigModule.forRoot({ envFilePath: [`${__dirname}/config/env/.${process.env.NODE_ENV}.env`], load: [emailConfig], isGlobal: true, validationSchema, }), ], controllers: [], providers: [], }) export class AppModule {} config/validateSchema.ts import * as Joi from \"joi\"; export const validateSchema = Joi.object({ EMAIL_SERVICE: Joi.string().required(), EMAIL_AUTH_USER: Joi.string().required(), EMAIL_AUTH_PASSWORD: Joi.string().required(), EMAIL_BASE_URL: Joi.string().required(), }); email.service.ts import Mail from 'nodemailer/lib/mailer'; import * as nodemailer from 'nodemailer'; import { Inject, Injectable } from '@nestjs/common'; import emailConfig from 'src/config/emailConfig'; import { ConfigType } from '@nestjs/config'; ... @Injectable() export class EmailService { private transporter: Mail; constructor( @Inject(emailConfig.KEY) private config: ConfigType&lt;typeof emailConfig&gt;, ) { this.transporter = nodemailer.createTransport({ service: config.service, auth: { user: config.auth.user, pass: config.auth.pass, }, }); } async sendMemberJoinVerification(email: string, signupVerifyToken: string) { const baseUrl = this.config.baseUrl; ... } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/28/07-nest-dynamic-module-env-config/"
  },{
    "title": "[NestJs] 모듈 설계",
    "text": "1. 모듈 1.1 모듈 다시 내보내기 1.2 전역 모듈 2. 유저 서비스 모듈 분리 2.1 UserModule 분리 2.2 EmailModule 분리 1. 모듈 모듈이란 여러 컴포넌트를 조합하여 더 큰 작업을 수행할 수 있게 하는 단위를 말한다. Nest 애플리케이션이 실행되기 위해서는 하나의 루트 모듈이 존재하고 이 루트 모듈은 다른 모듈들로 구성된다. 이를 통해 책임을 나누고 응집도를 높일 수 있다. 모듈을 어떻게 나눌 것인지는 명확한 기준은 없지만 유사한 기능끼리 모듈로 묶어서 설계하게 될 것이다. 모듈은 @Module 데커레이터를 사용한다. @Module 은 ModuleMetadata를 인수로 받으며 ModuleMetadata는 아래와 같이 정의된다. export declare function Module(metadata: ModuleMetadata): ClassDecorator; export interface ModuleMetadata { imports?: Array&lt;Type&lt;any&gt; | DynamicModule | Promise&lt;DynamicModule&gt; | ForwardReference&gt;; controllers?: Type&lt;any&gt;[]; providers?: Provider[]; exports?: Array&lt;DynamicModule | Promise&lt;DynamicModule&gt; | string | symbol | Provider | ForwardReference | Abstract&lt;any&gt; | Function&gt;; } import : 이 모듈에서 사용하기 위한 프로바이더를 가지고 있는 다른 모듈을 가지고 온다. controllers / providers : 컨트롤러와 프로바이더를 모듈에서 사용할수 있도록 Nest가 객체를 생성하고 주입할 수 있게 해준다. exports : 이 모듈에서 제공하는 컴포넌트를 다른 모듈에서 import 해서 사용하고자 한다면 export를 해야한다. export로 선언했다는 뜻은 어디서든 쓸 수 있으므로 public 인터페이스 또는 API로 간주된다. 1.1 모듈 다시 내보내기 가져온 모듈은 다시 내보내기가 가능하다. 예를 들어 AppModule이 CoreModule과 CommonModule의 기능이 모두 필요하다면 AppModule은 모두를 가지고 오는 것이 아니라 CoreModule만을 가져오고, CoreModule에서는 CommonModule을 내보내면 AppModule에서 CommonModule을 가지고 오지 않아도 사용할 수 있다. CommonModule.ts @Module({ providers: [CommonService], exports: [CommonService], // CommonService 제공 }) export class CommonModule {} CommonService.ts @Injectable() export class CommonService { hello(): string { return \"Common Hello~\"; } } CoreModule.ts @Module({ imports: [CommonModule], exports: [CommonModule], }) export class CoreModule {} AppModule.ts @Module({ imports: [CoreModule], controllers: [AppController], providers: [AppService], }) export class AppModule {} AppController.ts @Controller() export class AppController { constructor(private readonly commonService: CommonService) {} @Get('/common-hello') getCommonHello(): string { return this.commonService.hello(); } } 1.2 전역 모듈 Nest는 모듈 범위 내에서 프로바이더를 캡슐화한다. 따라서 어떤 모듈에 있는 프로바이더를 사용하려면 모듈을 먼저 import 해야한다. 하지만 헬퍼나 DB 연결 등의 전역적으로 쓸 수 있는 프로바이더가 필요한 경우 전역 모듈로 제공할 수 있다. 전역 모듈은 @Global 데커레이터를 선언한다. 전역 모듈은 루트 모듈이나 코어 모듈에서 한 번만 등록해야 한다. @Global() @Module({ providers: [CommonService], exports: [CommonService], }) export class CommonModule {} 2. 유저 서비스 모듈 분리 만들고 있는 유저 서비스는 루트 모듈인 AppModule만 존재한다. 유저 관리 기능을 UserModule로, 이메일 기능은 EmailModule로 분리하는 작업을 진행하자. 2.1 UserModule 분리 UserModule을 아래 cli 를 통해 생성한다. $ nest g mo Users 생성된 UserModule에 UserController와 UserService를 추가한다. EmailService를 사용하므로 함께 추가한다. user.module.ts import { Module } from \"@nestjs/common\"; import { UsersController } from \"./users.controller\"; import { UsersService } from \"./users.service\"; import { EmailService } from \"src/email/email.service\"; @Module({ imports: [], controllers: [UsersController], providers: [UsersService, EmailService], }) export class UsersModule {} AppModule에 UserModule이 자동으로 import 되어 있고 AppModule에서 UsersController, UsersService, EmailService를 참조할 필요가 없으므로 제거한다. app.module.ts import { Module } from \"@nestjs/common\"; import { UsersModule } from \"./users/users.module\"; @Module({ imports: [UsersModule], controllers: [], providers: [], }) export class AppModule {} 2.2 EmailModule 분리 이메일 모듈을 생성한다. $ nest g mo Email 생성된 EmailModule에서 EmailService를 UserModule에서 사용할수 있도록 exports 해준다. email.module.ts import { Module } from \"@nestjs/common\"; import { EmailService } from \"./email.service\"; @Module({ providers: [EmailService], exports: [EmailService], }) export class EmailModule {} UsersModule에서 EmailModule을 import해주고 EmailService는 삭제한다. users.module.ts import { Module } from \"@nestjs/common\"; import { UsersController } from \"./users.controller\"; import { UsersService } from \"./users.service\"; import { EmailModule } from \"src/email/email.module\"; @Module({ imports: [EmailModule], controllers: [UsersController], providers: [UsersService], }) export class UsersModule {} 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/27/06-nest-module/"
  },{
    "title": "[NestJs] 스코프",
    "text": "1. 스코프 1.1 프로바이더에 스코프 적용 1.2 컨트롤러에 스코프 적용 1. 스코프 Node.JS는 멀티 스레드 상태 비저장 모델을 따르지 않기 때문에 싱글턴 인스턴스를 사용하는 것이 권장된다. 하지만 요청별로 캐싱을 한다거나 요청 추적, 또는 멀티테넌시를 지원하기 위해서는 요청 기반으로 생명주기를 제한해야 한다. 아래는 스코프 종류이다. Default 싱글턴 인스턴스가 전체 애플리케이션에 공유됨 인스턴스 수명은 애플리케이션 생명주기와 같다. 애플리케이션이 부팅되면 모든 싱글턴 프로바이더의 인스턴스가 만들어진다. Request 들어오는 요청마다 별도의 인스턴스가 생성됨 요청을 처리하고 나면 인스턴스는 garbage-collected 됨 Transient 인스턴스는 공유되지 않는다. 이 프로바이더를 주입하는 각 컴포넌트는 새로 생성된 전용 인스턴스를 주입받는다. 1.1 프로바이더에 스코프 적용 @Injectable 데코레이터에 scope속성을 주는 방법 import { Injectable, Scope } from \"@nestjs/common\"; @Injectable({ scope: Scope.REQUEST }) export class CatsService {} 1.2 컨트롤러에 스코프 적용 @Controller 데코레이터는 ControllerOptions를 인수로 받을 수 있다. ContorllerOptions는 ScopeOptions를 상속한다. @Constroller({ path: \"cats\", scope: \"Scope.REQUEST\", }) export class CatsController {} 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/25/05-nest-scope/"
  },{
    "title": "[NestJs] 프로바이더",
    "text": "1. 프로바이더 1.1 프로바이더 등록 1.2 속성 기반 주입 2. 유저 서비스에 회원 가입 로직 구현 2.1 구현할 기능 목록 2.2 UserService 프로바이더 생성 2.3 회원 가입 2.4 회원 가입 이메일 발송 2.5 이메일 인증 2.6 로그인 2.7 유저 정보 조회 1. 프로바이더 앱이 제공하고자 하는 핵심 기능, 즉 비즈니스 로직을 수행하는 역하을 하는 것이 프로바이더이다. 컨트롤러가 이 역할을 수행하지 않고 분리함으로써 SRP에 부합하게 만든다. 프로바이더는 service, repository, factory, helper 등 여러 가지 형태로 구현이 가능하다. Nest에서 제공하는 프로바이더는 따로 라이브러리를 사용하지 않고 의존성을 주입할 수 있다. users.controller.ts @Controller('users') export class UsersController { constructor(private readonly usersService: UsersService) { } @Delete(':id') remove(@Param('id') id: string) { return this.usersService.remove(+id); } } 컨트롤러는 비즈니스 로직을 직접 수행하지 않는다. UsersController가 UsersService를 생성자를 통해 주입 받아서 멤버 변수에 할당해서 사용한다. 이때 UsersService에는 @Injectable 데코레이터를 선언해서 다른 어떤 Nest 컴포넌트에서도 주입할 수 있는 프로바이더가 된다. 별도의 스코프를 지정해주지 않으면 싱글턴 인스턴스가 된다. users.service.ts import { Injectable } from \"@nestjs/common\"; @Injectable() export class UsersService { remove(id: number) { return `This action removes a #${id} user`; } } 1.1 프로바이더 등록 module에서 등록을 해줘야 프로바이더로 사용할 수 있다. app.module.ts import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { UsersController } from \"./users/users.controller\"; @Module({ imports: [], controllers: [AppController, UsersController], providers: [AppService], }) export class AppModule {} 1.2 속성 기반 주입 프로바이더를 생성자를 통해 직접 주입받아 사용하지 않고 상속 관계에 있는 자식 클래스를 주입받아 사용하고 싶은 경우에 사용한다. export class BaseService { @Inject(ServiceA) private readonly serviceA: ServiceA; doSumeFuncFromA(): string { return this.serviceA.getHello(); } } BaseService 클래스의 ServieA 속성에 @Inject 데코레이터를 선언한다. 프로바이더에 정의된 클래스가 사용된다. 2. 유저 서비스에 회원 가입 로직 구현 2.1 구현할 기능 목록 회원 가입 이메일 인증 로그인 회원 정보 조회 2.2 UserService 프로바이더 생성 nest g s Users 명령어로 UsersService 프로바이더를 생성한다. app.module.ts에 UsersService가 자동으로 추가된다. 현재 src 디렉터리 내의 파일 구성은 아래와 같다. ├── app.controller.ts ├── app.module.ts ├── app.service.ts ├── main.ts └── users ├── UserInfo.ts ├── dto │ ├── create-user.dto.ts │ ├── user-login.dto.ts │ └── verify-email.dto.ts ├── users.controller.ts └── users.service.ts 2.3 회원 가입 회원 가입 요청을 구현한다. 먼저 POST /users 엔드포인트 담당 컨트롤러를 수정한다. uuid 라이브러리를 설치한다. $ npm i uuid users.controller.ts ... @Controller('users') export class UsersController { constructor(private userService: UsersService) {} // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { const { name, email, password } = dto; await this.userService.createUser(name, email, password); } ... UsersService를 생성자를 통해 주입받아 createUser에서 사용한다. UsersService 다음과 같이 구현한다. users.service.ts import { Injectable } from '@nestjs/common'; import * as uuid from 'uuid'; @Injectable() export class UsersService { async createUser( name: string, email: string, password: string, ): Promise&lt;void&gt; { await this.checkUserExists(email); const signupVerifyToken = uuid.v1(); await this.saveUser(name, email, password, signupVerifyToken); await this.sendMemberJoinEmail(email, signupVerifyToken); } private checkUserExists(email: string) { return false; // TODO: DB 연동 후 구현 } private saveUser( name: string, email: string, password: string, signupVerifyToken: string, ) { return; // TODO: DB 연동 후 구현 } private async sendMemberJoinEmail(email: string, signupVerifyToken: string) { return; // TODO: EmailService 프로바이더 구현 후 적용 } } 2.4 회원 가입 이메일 발송 여기서는 무료 이메일 전송 라이브러리인 nodemailer를 사용한다. $ npm i nodemailer $ npm i -D @types/nodemailer EmailService 프로바이더를 nest g s Email을 통해 생성한다. UserService에서 EmailService를 주입 받아서 sendMemverJoinEmail에서 emailService의 메소드를 호출한다. import { Injectable } from '@nestjs/common'; import { EmailService } from 'src/email/email.service'; import * as uuid from 'uuid'; @Injectable() export class UsersService { constructor(private emailService: EmailService) {} ... private async sendMemberJoinEmail(email: string, signupVerifyToken: string) { await this.emailService.sendMemberJoinVerification( email, signupVerifyToken, ); } } EmailService에서 sendMemberJoinVerification를 구현한다. import Mail from 'nodemailer/lib/mailer'; import * as nodemailer from 'nodemailer'; import { Injectable } from '@nestjs/common'; interface EmailOptions { to: string; subject: string; html: string; } @Injectable() export class EmailService { private transporter: Mail; constructor() { this.transporter = nodemailer.createTransport({ service: 'Gmail', auth: { user: 'YOUR_GMAIL', pass: 'YOUR_PASSWORD', }, }); } async sendMemberJoinVerification(email: string, signupVerifyToken: string) { const baseUrl = 'http://localhost:3000'; const url = `${baseUrl}/users/email-verify?signupVerifyToken=${signupVerifyToken}`; const mailOptions: EmailOptions = { to: email, subject: '가입 인증 메일', html: ` 가입확인 버튼을 누르시면 가입 인증이 완료됩니다.&lt;br/&gt; &lt;form action=\"${url}\" method=\"POST\"&gt; &lt;button&gt;가입확인&lt;/button&gt; &lt;/form&gt; `, }; return await this.transporter.sendMail(mailOptions); } } nodemailer는 구글 앱 비밀번호 로그인 를 참고하여 앱 비밀번호 설정해서 사용한다. 2.5 이메일 인증 받은 메일에서 가입확인 버튼을 눌렀을때 컨트롤러가 서비스 로직을 사용하도록 변경한다. users.controller.ts ... // 이메일 인증 @Post('/email-verify') async verifyEmail(@Query() dto: VerifyEmailDto): Promise&lt;void&gt; { const { signupVerifyToken } = dto; return await this.userService.verifyEmail(signupVerifyToken); } ... users.service.ts ... async verifyEmail(signupVerifyToken: string) { // TODO // 1. DB에서 signupVerifyToken으로 회원 가입 처리중인 유저가 있는지 조회하고 없다면 에러처리 // 2. 바로 로그인 상태가 되도록 JWT 발급 } ... 2.6 로그인 users.controller.ts ... // 로그인 @Post('login') async login(@Body() dto: UserLoginDto): Promise&lt;void&gt; { const { email, password } = dto; return await this.userService.login(email, password); } ... users.service.ts ... async login(email, password) { // TODO // 1. email, password를 가진 유저가 존재하는지 DB에서 확인하고 없다면 에러 처리 // 2. JWT 발급 } ... 2.7 유저 정보 조회 users.controller.ts ... // 회원 정보 조회 @Get(':id') async getUserInfo(@Param('id') userId: string): Promise&lt;UserInfo&gt; { return await this.userService.getUserInfo(userId); } ... users.service.ts ... async getUserInfo(userId: string): Promise&lt;UserInfo&gt; { // TODO // 1. UserId를 가진 유저가 존재하는지 DB에서 확인 후 없다면 에러 처리 // 2. 조회된 데이터를 UserInfo 타입으로 응답 throw new Error('Method not iplemented'); } ... 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/25/04-nest-provider/"
  },{
    "title": "[NestJs] 인터페이스",
    "text": "1. 컨트롤러 1.1 라우팅 1.2 요청 객체 1.3 응답 1.4 헤더 1.5 리디렉션 1.6 라우트 매개변수 1.7 하위 도메인 라우팅 1.9 페이로드 다루기 2. 유저 서비스의 인터페이스 1. 컨트롤러 Nest의 컨트롤러는 MVC 패턴에서 말하는 그 컨트롤러를 말한다. 컨트롤러는 들어오는 요청을 받고 처리된 결과를 응답으로 돌려주는 인터페이스 역할을 한다. 컨트롤러를 작성해보자. 프로젝트 생성 $ nest new my-project cli를 통한 컨트롤러 생성 $ nest g controller Users AppModule 에서 생성한 users.controller.ts를 import 하는 부분이 추가된다. cli를 통해 보일러 플레이트를 한번에 만들 수 있다. module, controller, service, entity, dto, test 코드 등이 한번에 만들어진다. $ nest g resource Users ? What transport layer do you use? REST API ? Would you like to generate CRUD entry points? Yes CREATE src/users/users.controller.spec.ts (566 bytes) CREATE src/users/users.controller.ts (894 bytes) CREATE src/users/users.module.ts (248 bytes) CREATE src/users/users.service.spec.ts (453 bytes) CREATE src/users/users.service.ts (609 bytes) CREATE src/users/dto/create-user.dto.ts (30 bytes) CREATE src/users/dto/update-user.dto.ts (169 bytes) CREATE src/users/entities/user.entity.ts (21 bytes) UPDATE package.json (1990 bytes) UPDATE src/app.module.ts (389 bytes) ✔ Packages installed successfully. 1.1 라우팅 app.controller.ts import { Controller, Get } from '@nestjs/common'; import { AppService } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); } } @Controller 데코레이터를 통해 해당 클래스는 컨트롤러 역할을 하게 된다. getHello 함수는 @GET 데코레이터를 통해 라우팅된다. 라우팅 경로는 @Get 데코레이터의 인수로 관리된다. @Controller 데코레이터에도 인수를 전달하여 라우팅 경로의 접두어를 지정할 수 있다. 예를 들어 @Controller(‘app’)이라고 하면 http://localhost:3000/app/hello 로 접근된다. 라우팅 패스는 와일드 카드를 이용하여 작성할 수 있다. @Get(‘/he*lo’) 로 설정하면 hello, helo, he_o 등으로 접근가능하고, * 외 ?, +, () 역시 정규 표현식에서의 와일드 카드와 동일하게 동작한다. 단, -, . 은 문자열로 취급한다. 1.2 요청 객체 Nest는 요청과 함께 전달되는 데이터를 핸들러가 다룰 수 있는 객체로 변환한다. 이 객체는 @Req 데코레이터로 다룰 수 있다. app.controller.ts import { Controller, Get, Req } from '@nestjs/common'; import { AppService } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(@Req() req: Request): string { console.log(req); return this.appService.getHello(); } } 1.3 응답 요청의 성공 응답 코드는 POST일 경우 201이고, 나머지는 모두 200이다. Nest는 응답을 어떤 방식으로 처리할지 미리 정의해두었다. 객체를 리턴한다면 직렬화를 통해 JSON으로 자동 변환해준다. @Res 데코레이터를 이용해서 응답 객체를 다룰 수 있다. @Get() findAll(@Res() res) { const users = this.usersService.findAll(); return res.status(200).send(users); } 응답 코드를 변경하고 싶을때는 @HttpCode로 변경할수 있다. import { HttpCode } from '@nestjs/common'; @HttpCode(202) @Get() findAll() { return this.usersService.findAll(); } 예외 처리로 에러 코드를 보낼때는 아래처럼 정의된 Exception 객체들을 사용해서 처리한다. @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 1.4 헤더 Nest는 헤더를 자동으로 구성해준다. 만약 커스텀 헤더를 추가하고 싶다면 @Header 데코레이터를 사용하면 된다. 인수로 헤더 이름과 값을 받는다. @Header('Custom', 'Test Header') @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 1.5 리디렉션 클라이언트를 다른 페이지로 이동하고 싶은 경우 @Redirect 데코레이터를 사용해 구현할수 있다. 두번째 인자는 상태 코드이다. @Redirect('https://google.com', 301) @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 요청 결과에 따라 동적으로 리디렉트할 때는 응답으로 다음 객체를 리턴하면 된다. { \"url\": string, \"statusCode\": number } 예를 들어 다음처럼 구현할 수 있다. @Get('redirect/docs') @Redirect('https://docs.nestjs.com', 302) getDocs(@Query('version') version) { if (version &amp;&amp; version === '5') { return { url: 'https://docs.nestjs.com/v5/'}; } } 1.6 라우트 매개변수 전달받은 매개변수는 함수 인수에 @Param 데코레이터 주입받을 수 있다. @Delete(':userId/memo/:memoId') deleteUserMemo( @Param('userId') userId: string, @Param('memoId') memoId: string, ) { return `userId: ${userId}, memoId: ${memoId}`; } 1.7 하위 도메인 라우팅 http://example.com, http://api.example.com 각 들어온 요청을 다르게 처리하고 싶을때 사용한다. 먼저 새로운 컨트롤러를 생성한다. $ nest g co Api ApiController가 먼저 처리되도록 라우팅 순서를 변경한다. @Module({ imports: [UsersModule], controllers: [ApiController, AppController], providers: [AppService], }) export class AppModule {} @Controller 데코레이터는 ControllerOptions 객체를 인수로 받는데, host 속성에 하위 도메인을 기술하면 된다. @Controller({ host: \"api.localhost\" }) // 하위 도메인 요청 처리 설정 export class ApiController { @Get() // 같은 루트 경로 index(): string { return \"Hello Api\"; // 다른 응답 } } @HostParam 데코레이터를 통해 서브 도메인을 변수로 받을 수 있다. @Controller({ host: \":version.api.localhost\" }) export class ApiController { @Get() index(@HostParam(\"version\") version: string): string { return `Hello, API ${version}`; } } 1.9 페이로드 다루기 NestJS에서는 데이터 전송 객체 (DTO)가 구현되어 있어 body를 쉽게 다룰 수 있다. 회원 가입 처리를 위해 이름과 이메일을 추가해보자. create-user.dto.ts export class CreateUserDto { name: string; email: string; } users.controller.ts @Post() create(@Body() createUserDto: CreateUserDto) { const { name, email } = createUserDto; return `Created User. name: ${name}, Email: ${email}`; } 2. 유저 서비스의 인터페이스 이 과정에서는 다음과 같이 요청에 대한 인터페이스를 정의한다. 기능 end-point body(json) path parameter response 회원 가입 POST /users { “name”: “assu”, email”: “email@test.com”, “password”: “abcd” }   201 이메일 인증 POST /users/email-verify { “signupVerifyToken”: “fdsafdsa”   201 AccessToken 로그인 POST /users/login { “email”: “email@test.com”, “password”: “fdsafd” }   201 AccessToken 회원 정보 조회 GET /users/:id   id 200 회원 정보 먼저 컨트롤러를 만든다. $ nest g co users 회원 가입 인터페이스 구현 users.controller.ts import { Body, Controller, Post } from \"@nestjs/common\"; import { CreateUserDto } from \"./dto/create-user.dto\"; @Controller(\"users\") export class UsersController { @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { console.log(dto); } } dto/create-user.dto.ts export class CreateUserDto { readonly name: string; readonly email: string; readonly password: string; } 나머지 인터페이스 구현 users.controller.ts import { Body, Controller, Get, Param, Post, Query } from \"@nestjs/common\"; import { CreateUserDto } from \"./dto/create-user.dto\"; import { VerifyEmailDto } from \"./dto/verify-email.dto\"; import { UserLoginDto } from \"./dto/user-login.dto\"; import { UserInfo } from \"./UserInfo\"; @Controller(\"users\") export class UsersController { // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { console.log(\"createUser dto: \", dto); } // 이메일 인증 @Post(\"/email-verify\") async verifyEmail(@Query() dto: VerifyEmailDto): Promise&lt;string&gt; { console.log(\"verifyEmail dto: \", dto); return; } // 로그인 @Post(\"login\") async login(@Body() dto: UserLoginDto): Promise&lt;string&gt; { console.log(\"login dto: \", dto); return; } // 회원 정보 조회 @Get(\":id\") async getUserInfo(@Param(\"id\") userId: string): Promise&lt;UserInfo&gt; { console.log(\"getUserInfo userId: \", userId); return; } } dto/verify-email.dto.ts export class VerifyEmailDto { signupVerifyToken: string; } dto/user-login.dto.ts export class UserLoginDto { email: string; password: string; } UserInfo.ts 유저 정보는 다음과 같은 인터페이스로 구성된다. export interface UserInfo { id: string; name: string; email: string; } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/24/03-nest-interface/"
  },{
    "title": "[NestJs] Decorator",
    "text": "1. 설정 2. 사용 예시 3. Decorator Factory 4. Decorator 합성 5. Decorator 역할 요약 Nest는 Decorator를 적극 활용한다. Decorator를 잘 사용하면 횡단 관심사를 분리하여 관점 지향 프로그래밍을 적용한 코드를 작성할 수 있다. 타입스크립트의 Decorator는 클래스, 메서드, 접근자, 프로퍼티, 매개변수에 적용 가능하다. 각 요소의 선언부 앞에 @로 시작하는 Decorator를 선언하면 구현된 코드가 함께 실행된다. 1. 설정 Decorator를 사용하려면 tsconfig.json의 experimentalDecorators 옵션을 true로 활성화해야 한다. tsconfig.json { \"compilerOptions\": { \"target\": \"ES5\", \"experimentalDecorators\": true } } 2. 사용 예시 function deco( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"Decorator 가 평가됨\"); } class TestClass { @deco test() { console.log(\"test 함수 호출\"); } } const t = new TestClass(); t.test(); &gt; Decorator 가 평가됨 &gt; test 함수 호출 3. Decorator Factory 만약 Decorator 에 인수를 넘기고 싶다면 Decorator Factory, 즉 Decorator를 리턴하는 함수를 만들면 된다. function deco(value: string) { console.log(\"Decorator 평가됨\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(value); }; } class TestClass { @deco(\"Hello\") test() { console.log(\"함수 호출됨\"); } } const t = new TestClass(); t.test(); &gt; Decorator 평가됨 &gt; Hello &gt; 함수 호출됨 4. Decorator 합성 여러 개의 Decorator를 사용한다면 다음과 같이 선언한다. 각 표현은 위에서 아래로 평가된다. 결과는 아래에서 위로 함수를 호출한다. function first() { console.log(\"first(): factory evaluated\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"first(): called\"); }; } function second() { console.log(\"second(): factory evaluated\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"second(): called\"); }; } class ExampleClass { @first() @second() method() {} } &gt; first(): factory evaluated &gt; second(): factory evaluated &gt; second(): called &gt; first(): called 5. Decorator 역할 요약 Decorator 역할 전달 인수 선언 불가능 위치 Class Decorator 클래스의 정의를 읽거나 수정 constructor d.ts 파일, declare 클래스 Method Decorator 메서드의 정의를 읽거나 수정 target, propertyKey, propertyDescriptor d.ts 파일, declare 클래스, 오버로드 메서드 Accessor Decorator 접근자의 정의를 읽거나 수정 target, propertyKey, propertyDescriptor d.ts 파일, declare 클래스 Property Decorator 속성의 정의를 읽거나 수정 target, propertyKey d.ts 파일, declare 클래스 Parameter Decorator 매개변수의 정의를 읽음 target, propertyKey, parameterIndex d.ts 파일, declare 클래스 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/23/02-nest-decorator/"
  },{
    "title": "[NestJs] NestJs 장점 및 설치",
    "text": "1. NestJS 장점 2. NestJS 설치 3. NestJS 보일러플레이트 4. 서버 실행 1. NestJS 장점 NestJS는 Express 또는 Fastify 프레임워크를 래핑하여 동작한다. Fastify는 Express보다 벤치마크 결과 2배 빠른 속도를 자랑한다. NestJS는 Fastify의 빠른 속도와 Express의 높은 호환성을 갖고자 한다. Node.js 의 과도한 유연함으로 인해 발생하는 문제점을 해결하기 위해 데이터베이스. 객체 관계 매핑(ORM), 설정, 유효성 검사 등의 기능을 기본으로 제공한다. 그러면서도 필요한 라이브러리를 쉽게 설치하여 사용하는 Node.JS 장점은 그대로 가지고 있다. 모듈/컴포넌트 기반으로 프로그램을 작성함으로써 재사용성을 높인다. 또 제어 반전, 의존성 주입, 관점 지향 프로그래밍 같은 객체 지향 개념을 도입했다. 기본으로 타입스크립트를 채택하고 있다. 2. NestJS 설치 Mac 버전으로 설명한다. NodeJS 먼저 설치한다. https://nodejs.org/en @nestjs/cli 를 npm으로 설치한다. $ npm i -g @nestjs/cli 프로젝트를 생성한다. $ nest new project-name 3. NestJS 보일러플레이트 ├── README.md ├── nest-cli.json ├── package-lock.json ├── package.json ├── src │ ├── app.controller.spec.ts │ ├── app.controller.ts │ ├── app.module.ts │ ├── app.service.ts │ └── main.ts ├── test │ ├── app.e2e-spec.ts │ └── jest-e2e.json ├── tsconfig.build.json └── tsconfig.json 4. 서버 실행 $ npm i $ npm run start:dev [5:51:40 PM] Starting compilation in watch mode... [5:51:41 PM] Found 0 errors. Watching for file changes. [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [NestFactory] Starting Nest application... [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [InstanceLoader] AppModule dependencies initialized +10ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [RoutesResolver] AppController {/}: +4ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [RouterExplorer] Mapped {/, GET} route +2ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [NestApplication] Nest application successfully started +2ms localhost에서 구동된 것을 확인할 수 있다. 포트는 기본으로 main.ts 에서 3000번으로 설정되어 있다. 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/23/01-nest-basic/"
  }]};
