var tipuesearch = {"pages": [{
    "title": "[NestJs] 스코프",
    "text": "1. 스코프 1.1 프로바이더에 스코프 적용 1.2 컨트롤러에 스코프 적용 1. 스코프 Node.JS는 멀티 스레드 상태 비저장 모델을 따르지 않기 때문에 싱글턴 인스턴스를 사용하는 것이 권장된다. 하지만 요청별로 캐싱을 한다거나 요청 추적, 또는 멀티테넌시를 지원하기 위해서는 요청 기반으로 생명주기를 제한해야 한다. 아래는 스코프 종류이다. Default 싱글턴 인스턴스가 전체 애플리케이션에 공유됨 인스턴스 수명은 애플리케이션 생명주기와 같다. 애플리케이션이 부팅되면 모든 싱글턴 프로바이더의 인스턴스가 만들어진다. Request 들어오는 요청마다 별도의 인스턴스가 생성됨 요청을 처리하고 나면 인스턴스는 garbage-collected 됨 Transient 인스턴스는 공유되지 않는다. 이 프로바이더를 주입하는 각 컴포넌트는 새로 생성된 전용 인스턴스를 주입받는다. 1.1 프로바이더에 스코프 적용 @Injectable 데코레이터에 scope속성을 주는 방법 import { Injectable, Scope } from \"@nestjs/common\"; @Injectable({ scope: Scope.REQUEST }) export class CatsService {} 1.2 컨트롤러에 스코프 적용 @Controller 데코레이터는 ControllerOptions를 인수로 받을 수 있다. ContorllerOptions는 ScopeOptions를 상속한다. @Constroller({ path: \"cats\", scope: \"Scope.REQUEST\", }) export class CatsController {} 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/25/nest-scope/"
  },{
    "title": "[NestJs] 프로바이더",
    "text": "1. 프로바이더 1.1 프로바이더 등록 1.2 속성 기반 주입 2. 유저 서비스에 회원 가입 로직 구현 2.1 구현할 기능 목록 2.2 UserService 프로바이더 생성 2.3 회원 가입 2.4 회원 가입 이메일 발송 2.5 이메일 인증 2.6 로그인 2.7 유저 정보 조회 1. 프로바이더 앱이 제공하고자 하는 핵심 기능, 즉 비즈니스 로직을 수행하는 역하을 하는 것이 프로바이더이다. 컨트롤러가 이 역할을 수행하지 않고 분리함으로써 SRP에 부합하게 만든다. 프로바이더는 service, repository, factory, helper 등 여러 가지 형태로 구현이 가능하다. Nest에서 제공하는 프로바이더는 따로 라이브러리를 사용하지 않고 의존성을 주입할 수 있다. user.controller.ts @Controller('users') export class UsersController { constructor(private readonly usersService: UsersService) { } @Delete(':id') remove(@Param('id') id: string) { return this.usersService.remove(+id); } } 컨트롤러는 비즈니스 로직을 직접 수행하지 않는다. UsersController가 UsersService를 생성자를 통해 주입 받아서 멤버 변수에 할당해서 사용한다. 이때 UsersService에는 @Injectable 데코레이터를 선언해서 다른 어떤 Nest 컴포넌트에서도 주입할 수 있는 프로바이더가 된다. 별도의 스코프를 지정해주지 않으면 싱글턴 인스턴스가 된다. import { Injectable } from \"@nestjs/common\"; @Injectable() export class UsersService { remove(id: number) { return `This action removes a #${id} user`; } } 1.1 프로바이더 등록 module에서 등록을 해줘야 프로바이더로 사용할 수 있다. app.module.ts import { Module } from \"@nestjs/common\"; import { AppController } from \"./app.controller\"; import { AppService } from \"./app.service\"; import { UsersController } from \"./users/users.controller\"; @Module({ imports: [], controllers: [AppController, UsersController], providers: [AppService], }) export class AppModule {} 1.2 속성 기반 주입 프로바이더를 생성자를 통해 직접 주입받아 사용하지 않고 상속 관계에 있는 자식 클래스를 주입받아 사용하고 싶은 경우에 사용한다. export class BaseService { @Inject(ServiceA) private readonly serviceA: ServiceA; doSumeFuncFromA(): string { return this.serviceA.getHello(); } } BaseService 클래스의 ServieA 속성에 @Inject 데코레이터를 선언한다. 프로바이더에 정의된 클래스가 사용된다. 2. 유저 서비스에 회원 가입 로직 구현 2.1 구현할 기능 목록 회원 가입 이메일 인증 로그인 회원 정보 조회 2.2 UserService 프로바이더 생성 nest g s Users 명령어로 UsersService 프로바이더를 생성한다. app.module.ts에 UsersService가 자동으로 추가된다. 현재 src 디렉터리 내의 파일 구성은 아래와 같다. ├── app.controller.ts ├── app.module.ts ├── app.service.ts ├── main.ts └── users ├── UserInfo.ts ├── dto │ ├── create-user.dto.ts │ ├── user-login.dto.ts │ └── verify-email.dto.ts ├── users.controller.ts └── users.service.ts 2.3 회원 가입 회원 가입 요청을 구현한다. 먼저 POST /users 엔드포인트 담당 컨트롤러를 수정한다. uuid 라이브러리를 설치한다. $ npm i uuid users.controller.ts ... @Controller('users') export class UsersController { constructor(private userService: UsersService) {} // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { const { name, email, password } = dto; await this.userService.createUser(name, email, password); } ... UsersService를 생성자를 통해 주입받아 createUser에서 사용한다. UsersService 다음과 같이 구현한다. users.service.ts import { Injectable } from '@nestjs/common'; import * as uuid from 'uuid'; @Injectable() export class UsersService { async createUser( name: string, email: string, password: string, ): Promise&lt;void&gt; { await this.checkUserExists(email); const signupVerifyToken = uuid.v1(); await this.saveUser(name, email, password, signupVerifyToken); await this.sendMemberJoinEmail(email, signupVerifyToken); } private checkUserExists(email: string) { return false; // TODO: DB 연동 후 구현 } private saveUser( name: string, email: string, password: string, signupVerifyToken: string, ) { return; // TODO: DB 연동 후 구현 } private async sendMemberJoinEmail(email: string, signupVerifyToken: string) { return; // TODO: EmailService 프로바이더 구현 후 적용 } } 2.4 회원 가입 이메일 발송 여기서는 무료 이메일 전송 라이브러리인 nnodemailer를 사용한다. $ npm i nodemailer $ npm i -D @types/nodemailer EmailService 프로바이더를 nest g s Email을 통해 생성한다. UserService에서 EmailService를 주입 받아서 sendMemverJoinEmail에서 emailService의 메소드를 호출한다. import { Injectable } from '@nestjs/common'; import { EmailService } from 'src/email/email.service'; import * as uuid from 'uuid'; @Injectable() export class UsersService { constructor(private emailService: EmailService) {} ... private async sendMemberJoinEmail(email: string, signupVerifyToken: string) { await this.emailService.sendMemberJoinVerification( email, signupVerifyToken, ); } } EmailService에서 sendMemberJoinVerification를 구현한다. import Mail from 'nodemailer/lib/mailer'; import * as nodemailer from 'nodemailer'; import { Injectable } from '@nestjs/common'; interface EmailOptions { to: string; subject: string; html: string; } @Injectable() export class EmailService { private transporter: Mail; constructor() { this.transporter = nodemailer.createTransport({ service: 'Gmail', auth: { user: 'YOUR_GMAIL', pass: 'YOUR_PASSWORD', }, }); } async sendMemberJoinVerification(email: string, signupVerifyToken: string) { const baseUrl = 'http://localhost:3000'; const url = `${baseUrl}/users/email-verify?signupVerifyToken=${signupVerifyToken}`; const mailOptions: EmailOptions = { to: email, subject: '가입 인증 메일', html: ` 가입확인 버튼을 누르시면 가입 인증이 완료됩니다.&lt;br/&gt; &lt;form action=\"${url}\" method=\"POST\"&gt; &lt;button&gt;가입확인&lt;/button&gt; &lt;/form&gt; `, }; return await this.transporter.sendMail(mailOptions); } } nodemailer는 구글 앱 비밀번호 로그인 를 참고하여 앱 비밀번호 설정해서 사용한다. 2.5 이메일 인증 받은 메일에서 가입확인 버튼을 눌렀을때 컨트롤러가 서비스 로직을 사용하도록 변경한다. users.controller.ts ... // 이메일 인증 @Post('/email-verify') async verifyEmail(@Query() dto: VerifyEmailDto): Promise&lt;void&gt; { const { signupVerifyToken } = dto; return await this.userService.verifyEmail(signupVerifyToken); } ... users.service.ts ... async verifyEmail(signupVerifyToken: string) { // TODO // 1. DB에서 signupVerifyToken으로 회원 가입 처리중인 유저가 있는지 조회하고 없다면 에러처리 // 2. 바로 로그인 상태가 되도록 JWT 발급 } ... 2.6 로그인 users.controller.ts ... // 로그인 @Post('login') async login(@Body() dto: UserLoginDto): Promise&lt;void&gt; { const { email, password } = dto; return await this.userService.login(email, password); } ... users.service.ts ... async login(email, password) { // TODO // 1. email, password를 가진 유저가 존재하는지 DB에서 확인하고 없다면 에러 처리 // 2. JWT 발급 } ... 2.7 유저 정보 조회 users.controller.ts ... // 회원 정보 조회 @Get(':id') async getUserInfo(@Param('id') userId: string): Promise&lt;UserInfo&gt; { return await this.userService.getUserInfo(userId); } ... users.service.ts ... async getUserInfo(userId: string): Promise&lt;UserInfo&gt; { // TODO // 1. UserId를 가진 유저가 존재하는지 DB에서 확인 후 없다면 에러 처리 // 2. 조회된 데이터를 UserInfo 타입으로 응답 throw new Error('Method not iplemented'); } ... 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/25/nest-provider/"
  },{
    "title": "[NestJs] 인터페이스",
    "text": "1. 컨트롤러 1.1 라우팅 1.2 요청 객체 1.3 응답 1.4 헤더 1.5 리디렉션 1.6 라우트 매개변수 1.7 하위 도메인 라우팅 1.9 페이로드 다루기 2. 유저 서비스의 인터페이스 1. 컨트롤러 Nest의 컨트롤러는 MVC 패턴에서 말하는 그 컨트롤러를 말한다. 컨트롤ㄹ러는 들어오는 요청을 받고 처리된 결과를 응답으로 돌려주는 인터페이스 역할을 한다. 컨트롤러를 작성해보자. 프로젝트 생성 $ nest new my-project cli를 통한 컨트롤러 생성 $ nest g controller Users AppModule 에서 생성한 users.controller.ts를 import 하는 부분이 추가된다. cli를 통해 보일러 플레이트를 한번에 만들 수 있다. module, controller, service, entity, dto, test 코드 등이 한번에 만들어진다. $ nest g resource Users ? What transport layer do you use? REST API ? Would you like to generate CRUD entry points? Yes CREATE src/users/users.controller.spec.ts (566 bytes) CREATE src/users/users.controller.ts (894 bytes) CREATE src/users/users.module.ts (248 bytes) CREATE src/users/users.service.spec.ts (453 bytes) CREATE src/users/users.service.ts (609 bytes) CREATE src/users/dto/create-user.dto.ts (30 bytes) CREATE src/users/dto/update-user.dto.ts (169 bytes) CREATE src/users/entities/user.entity.ts (21 bytes) UPDATE package.json (1990 bytes) UPDATE src/app.module.ts (389 bytes) ✔ Packages installed successfully. 1.1 라우팅 app.controller.ts import { Controller, Get } from '@nestjs/common'; import { AppService } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); } } @Controller 데코레이터를 통해 해당 클래스는 컨트롤러 역할을 하게 된다. getHello 함수는 @GET 데코레이터를 통해 라우팅된다. 라우팅 경로는 @Get 데코레이터의 인수로 관리된다. @Controller 데코레이터에도 인수를 전달하여 라우팅 경로의 접두어를 지정할 수 있다. 예를 들어 @Controller(‘app’)이라고 하면 http://localhost:3000/app/hello 로 접근된다. 라우팅 패스는 와일드 카드를 이용하여 작성할 수 있다. @Get(‘/he*lo’) 로 설정하면 hello, helo, he_o 등으로 접근가능하고, * 외 ?, +, () 역시 정규 표현식에서의 와일드 카드와 동일하게 동작한다. 단, -, . 은 문자열로 취급한다. 1.2 요청 객체 Nest는 요청과 함께 전달되는 데이터를 핸들러가 다룰 수 있는 객체로 변환한다. 이 객체는 @Req 데코레이터로 다룰 수 있다. app.controller.ts import { Controller, Get, Req } from '@nestjs/common'; import { AppService } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(@Req() req: Request): string { console.log(req); return this.appService.getHello(); } } 1.3 응답 요청의 성공 응답 코드는 POST일 경우 201이고, 나머지는 모두 200이다. Nest는 응답을 어떤 방식으로 처리할지 미리 정의해두었다. 객체를 리턴한다면 직렬화를 통해 JSON으로 자동 변환해준다. @Res 데코레이터를 이용해서 응답 객체를 다룰 수 있다. @Get() findAll(@Res() res) { const users = this.usersService.findAll(); return res.status(200).send(users); } 응답 코드를 변경하고 싶을때는 @HttpCode로 변경할수 있다. import { HttpCode } from '@nestjs/common'; @HttpCode(202) @Get() findAll() { return this.usersService.findAll(); } 예외 처리로 에러 코드를 보낼때는 아래처럼 정의된 Exception 객체들을 사용해서 처리한다. @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 1.4 헤더 Nest는 헤더를 자동으로 구성해준다. 만약 커스텀 헤더를 추가하고 싶다면 @Header 데코레이터를 사용하면 된다. 인수로 헤더 이름과 값을 받는다. @Header('Custom', 'Test Header') @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 1.5 리디렉션 클라이언트를 다른 페이지로 이동하고 싶은 경우 @Redirect 데코레이터를 사용해 구현할수 있다. 두번째 인자는 상태 코드이다. @Redirect('https://google.com', 301) @Get(':id') findOne(@Param('id') id: string) { if (+id &lt; 1) { throw new BadRequestException('id error'); } return this.usersService.findOne(+id); } 요청 결과에 따라 동적으로 리디렉트할 때는 응답으로 다음 객체를 리턴하면 된다. { \"url\": string, \"statusCode\": number } 예를 들어 다음처럼 구현할 수 있다. @Get('redirect/docs') @Redirect('https://docs.nestjs.com', 302) getDocs(@Query('version') version) { if (version &amp;&amp; version === '5') { return { url: 'https://docs.nestjs.com/v5/'}; } } 1.6 라우트 매개변수 전달받은 매개변수는 함수 인수에 @Param 데코레이터 주입받을 수 있다. @Delete(':userId/memo/:memoId') deleteUserMemo( @Param('userId') userId: string, @Param('memoId') memoId: string, ) { return `userId: ${userId}, memoId: ${memoId}`; } 1.7 하위 도메인 라우팅 http://example.com, http://api.example.com 각 들어온 요청을 다르게 처리하고 싶을때 사용한다. 먼저 새로운 컨트롤러를 생성한다. $ nest g co Api ApiController가 먼저 처리되도록 라우팅 순서를 변경한다. @Module({ imports: [UsersModule], controllers: [ApiController, AppController], providers: [AppService], }) export class AppModule {} @Controller 데코레이터는 ControllerOptions 객체를 인수로 받는데, host 속성에 하위 도메인을 기술하면 된다. @Controller({ host: \"api.localhost\" }) // 하위 도메인 요청 처리 설정 export class ApiController { @Get() // 같은 루트 경로 index(): string { return \"Hello Api\"; // 다른 응답 } } @HostParam 데코레이터를 통해 서브 도메인을 변수로 받을 수 있다. @Controller({ host: \":version.api.localhost\" }) export class ApiController { @Get() index(@HostParam(\"version\") version: string): string { return `Hello, API ${version}`; } } 1.9 페이로드 다루기 NestJS에서는 데이터 전송 객체 (DTO)가 구현되어 있어 body를 쉽게 다룰 수 있다. 회원 가입 처리를 위해 이름과 이메일을 추가해보자. create-user.dto.ts export class CreateUserDto { name: string; email: string; } users.controller.ts @Post() create(@Body() createUserDto: CreateUserDto) { const { name, email } = createUserDto; return `Created User. name: ${name}, Email: ${email}`; } 2. 유저 서비스의 인터페이스 이 과정에서는 다음과 같이 요청에 대한 인터페이스를 정의한다. 기능 end-point body(json) path parameter response 회원 가입 POST /users { “name”: “assu”, email”: “email@test.com”, “password”: “abcd” }   201 이메일 인증 POST /users/email-verify { “signupVerifyToken”: “fdsafdsa”   201 AccessToken 로그인 POST /users/login { “email”: “email@test.com”, “password”: “fdsafd” }   201 AccessToken 회원 정보 조회 GET /users/:id   id 200 회원 정보 먼저 컨트롤러를 만든다. $ nest g co users 회원 가입 인터페이스 구현 users.controller.ts import { Body, Controller, Post } from \"@nestjs/common\"; import { CreateUserDto } from \"./dto/create-user.dto\"; @Controller(\"users\") export class UsersController { @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { console.log(dto); } } dto/create-user.dto.ts export class CreateUserDto { readonly name: string; readonly email: string; readonly password: string; } 나머지 인터페이스 구현 users.controller.ts import { Body, Controller, Get, Param, Post, Query } from \"@nestjs/common\"; import { CreateUserDto } from \"./dto/create-user.dto\"; import { VerifyEmailDto } from \"./dto/verify-email.dto\"; import { UserLoginDto } from \"./dto/user-login.dto\"; import { UserInfo } from \"./UserInfo\"; @Controller(\"users\") export class UsersController { // 회원 가입 @Post() async createUser(@Body() dto: CreateUserDto): Promise&lt;void&gt; { console.log(\"createUser dto: \", dto); } // 이메일 인증 @Post(\"/email-verify\") async verifyEmail(@Query() dto: VerifyEmailDto): Promise&lt;string&gt; { console.log(\"verifyEmail dto: \", dto); return; } // 로그인 @Post(\"login\") async login(@Body() dto: UserLoginDto): Promise&lt;string&gt; { console.log(\"login dto: \", dto); return; } // 회원 정보 조회 @Get(\":id\") async getUserInfo(@Param(\"id\") userId: string): Promise&lt;UserInfo&gt; { console.log(\"getUserInfo userId: \", userId); return; } } dto/verify-email.dto.ts export class VerifyEmailDto { signupVerifyToken: string; } dto/user-login.dto.ts export class UserLoginDto { email: string; password: string; } UserInfo.ts 유저 정보는 다음과 같은 인터페이스로 구성된다. export interface UserInfo { id: string; name: string; email: string; } 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/24/nest-interface/"
  },{
    "title": "[NestJs] Decorator",
    "text": "1. 설정 2. 사용 예시 3. Decorator Factory 4. Decorator 합성 5. Decorator 역할 요약 Nest는 Decorator를 적극 활용한다. Decorator를 잘 사용하면 횡단 관심사를 분리하여 관점 지향 프로그래밍을 적용한 코드를 작성할 수 있다. 타입스크립트의 Decorator는 클래스, 메서드, 접근자, 프로퍼티, 매개변수에 적용 가능하다. 각 요소의 선언부 앞에 @로 시작하는 Decorator를 선언하면 구현된 코드가 함께 실행된다. 1. 설정 Decorator를 사용하려면 tsconfig.json의 experimentalDecorators 옵션을 true로 활성화해야 한다. tsconfig.json { \"compilerOptions\": { \"target\": \"ES5\", \"experimentalDecorators\": true } } 2. 사용 예시 function deco( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"Decorator 가 평가됨\"); } class TestClass { @deco test() { console.log(\"test 함수 호출\"); } } const t = new TestClass(); t.test(); &gt; Decorator 가 평가됨 &gt; test 함수 호출 3. Decorator Factory 만약 Decorator 에 인수를 넘기고 싶다면 Decorator Factory, 즉 Decorator를 리턴하는 함수를 만들면 된다. function deco(value: string) { console.log(\"Decorator 평가됨\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(value); }; } class TestClass { @deco(\"Hello\") test() { console.log(\"함수 호출됨\"); } } const t = new TestClass(); t.test(); &gt; Decorator 평가됨 &gt; Hello &gt; 함수 호출됨 4. Decorator 합성 여러 개의 Decorator를 사용한다면 다음과 같이 선언한다. 각 표현은 위에서 아래로 평가된다. 결과는 아래에서 위로 함수를 호출한다. function first() { console.log(\"first(): factory evaluated\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"first(): called\"); }; } function second() { console.log(\"second(): factory evaluated\"); return function ( target: any, propertyKey: string, descriptor: PropertyDescriptor ) { console.log(\"second(): called\"); }; } class ExampleClass { @first() @second() method() {} } &gt; first(): factory evaluated &gt; second(): factory evaluated &gt; second(): called &gt; first(): called 5. Decorator 역할 요약 Decorator 역할 전달 인수 선언 불가능 위치 Class Decorator 클래스의 정의를 읽거나 수정 constructor d.ts 파일, declare 클래스 Method Decorator 메서드의 정의를 읽거나 수정 target, propertyKey, propertyDescriptor d.ts 파일, declare 클래스, 오버로드 메서드 Accessor Decorator 접근자의 정의를 읽거나 수정 target, propertyKey, propertyDescriptor d.ts 파일, declare 클래스 Property Decorator 속성의 정의를 읽거나 수정 target, propertyKey d.ts 파일, declare 클래스 Parameter Decorator 매개변수의 정의를 읽음 target, propertyKey, parameterIndex d.ts 파일, declare 클래스 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/23/nest-decorator/"
  },{
    "title": "[NestJs] NestJs 장점 및 설치",
    "text": "1. NestJS 장점 2. NestJS 설치 3. NestJS 보일러플레이트 4. 서버 실행 1. NestJS 장점 NestJS는 Express 또는 Fastify 프레임워크를 래핑하여 동작한다. Fastify는 Express보다 벤치마크 결과 2배 빠른 속도를 자랑한다. NestJS는 Fastify의 빠른 속도와 Express의 높은 호환성을 갖고자 한다. Node.js 의 과도한 유연함으로 인해 발생하는 문제점을 해결하기 위해 데이터베이스. 객체 관계 매핑(ORM), 설정, 유효성 검사 등의 기능을 기본으로 제공한다. 그러면서도 필요한 라이브러리를 쉽게 설치하여 사용하는 Node.JS 장점은 그대로 가지고 있다. 모듈/컴포넌트 기반으로 프로그램을 작성함으로써 재사용성을 높인다. 또 제어 반전, 의존성 주입, 관점 지향 프로그래밍 같은 객체 지향 개념을 도입했다. 기본으로 타입스크립트를 채택하고 있다. 2. NestJS 설치 Mac 버전으로 설명한다. NodeJS 먼저 설치한다. https://nodejs.org/en @nestjs/cli 를 npm으로 설치한다. $ npm i -g @nestjs/cli 프로젝트를 생성한다. $ nest new project-name 3. NestJS 보일러플레이트 ├── README.md ├── nest-cli.json ├── package-lock.json ├── package.json ├── src │ ├── app.controller.spec.ts │ ├── app.controller.ts │ ├── app.module.ts │ ├── app.service.ts │ └── main.ts ├── test │ ├── app.e2e-spec.ts │ └── jest-e2e.json ├── tsconfig.build.json └── tsconfig.json 4. 서버 실행 $ npm i $ npm run start:dev [5:51:40 PM] Starting compilation in watch mode... [5:51:41 PM] Found 0 errors. Watching for file changes. [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [NestFactory] Starting Nest application... [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [InstanceLoader] AppModule dependencies initialized +10ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [RoutesResolver] AppController {/}: +4ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [RouterExplorer] Mapped {/, GET} route +2ms [Nest] 32419 - 02/25/2023, 5:51:42 PM LOG [NestApplication] Nest application successfully started +2ms localhost에서 구동된 것을 확인할 수 있다. 포트는 기본으로 main.ts 에서 3000번으로 설정되어 있다. 본 포스트는 한용재 저자의 NestJS로 배우는 백엔드 프로그래밍을 기반으로 스터디하며 정리한 내용들입니다. NestJS로 배우는 백엔드 프로그래밍",
    "tags": "nestjs dev",
    "url": "/dev/2024/02/23/nest-basic/"
  }]};
